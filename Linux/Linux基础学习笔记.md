#  ..Linux基础学习day1

## 1、快捷键

- 记住常用的终端快捷键可以提高开发效率

  ctrl+alt+t：新开终端

  ctrl+shift+t：新开并堆叠终端窗口

  ctrl+shift+w：关闭当前终端窗口

  alt+数字可以切换堆叠的终端窗口

  ctrl+shift+c：复制

  ctrl+shift+v：粘贴

  ctrl+u：删除行

  del：包括光标本身在内往后删除

  backspace：不包括光标在内往前删除

  书写是在光标前面写入

  记住下面图片快捷键可以摆脱方向键盘

![1643510406024](./Linux基础学习笔记.assets/1643510406024.png)



##2、系统根目录

- bin：存放二进制可执行文件，平时在终端写命令都是通过shell（bash）解释然后调用bin中的可执行文件

- boot：系统开机启动相关的程序

- dev：存放设备的映射文件

	 etc：存放系统配置和用户信息的配置文件，	像用户信息文件passwd文件和组信息group文件

- lib：存放系统的库文件，像c的标准库等

- media和mnt：挂载外部磁盘相关的，默认挂载在media

- opt和proc：系统编程和进程相关的

- usr：用户资源管理文件，存放用户安装的软件和第三方库等，

- root：管理员宿主目录（家目录：根目录下的root目录   即：/root）

  ​

  ![1643512338025](./Linux基础学习笔记.assets/1643512338025.png)

  ​

## 3、常用目录文件命令

### 1、cd

- cd 可以回到当前用户的用户目录
- cd -  可以在最近两次工作目录下来回切换

### 2、rm

- -r  递归删除文件夹
- -f 强制删除

### 3、ls

- -l 查看文件夹和文件信息
- -h 人性化显示
- -R 递归查看
- 最后参数可以加文件夹路径，即为查看该文件夹下的文件信息
- -d 查看该文件夹的信息

### 4、which

- which+命令查看该命令的执行文件所在的目录

### 5、cp

- -a 用于拷贝文件夹包括其所有权限
- -r 用于递归拷贝文件夹

### 6、cat

- 倒着写可以倒着输出，方便查看大文件
- cat后可以进行终端回显，你打什么它显示什么

### 7、more

- 分屏显示

### 8、head

- 默认显示文件前十行加上-数字可以指定显示行数

### 9、tail

- 与head相反，显示末尾

### 10、du和df

- du用于查看某个目录大小
- df用于查看磁盘挂载的终端进程

## 4、文件属性和用户组管理命令

### 1、whoami

### 2、chmod

- 文字设定法 使用± u g o设定用户、组、其他人的权限 


- 更改权限 +rwx或-rwx

- 使用数字作为选项，二进制选择，3个数字分别代表用户权限、组权限、其他人的权限。

  例子：chmod 675 文件名  ==数字前不用一个短杆==

### 3、chown和chgrp

- 修改文件所属用户 chown 

- ![1643524800369](./Linux基础学习笔记.assets/1643524800369.png)

- 修改文件所属组chgrp

- ![1643524919532](./Linux基础学习笔记.assets/1643524919532.png)

- 一次修改文件所属者和所属组

- ![1643526799471](./Linux基础学习笔记.assets/1643526799471.png)

  ​

### 4、useradd

- 使用选项-m，默认创建用户目录
- adduser 创建时默认创建用户家目录，并且提示设置密码

### 5、userdel

- 使用选线-r，删除用户目录和邮件等
- deluser

## 5、查找命令

### 1、find

- 查找的是文件


- ![1643528421407](./Linux基础学习笔记.assets/1643528421407.png)
- -exec 后面{} \;   注意分号要有，相当于管道，将前面find的结果集进行-exec后面的指令
- -xargs默认是以空格拆分，当文件名中含有空格时，需要在查到的每个结果print0，然后以print0为拆分依据
- find 查找结果想通过管道处理得加上xargs

### 2、grep

- 查找的是文件内容，一般配合cat或more命令加上管道进行查找

  cat 文件路径|grep 搜索内容

- grep -r是递归查找 比如grep -r  -n  "copy"  ./ 表示在当前目录下递归查找文件中内容有copy的行，并标识行号



## 6、Linux系统文件类型

- 普通文件：- ，但是查找的时候使用-f进行查找
- 目录文件：d
- 字符设备文件：c
- 块设备文件：b
- 软连接：l
- 管道文件：p
- 套接字：s
- 位置文件
- Tip：用ls -l显示的第一个字母为文件类型

## 7、软链接和硬链接

### 1、软链接（是真存着路径的文件）

ln -s  绝对路径  快捷方式路径+名称

相当于一个==快捷方式==（软链接记录的只是一个路径名），一般使用绝对路径进行创建，这样移动快捷方式后还能继续使用，删除原本文件后软链接失效

### 2、硬链接

ln  绝对路径 快捷方式路径+名称

相当于给文件起了个别名，删除原本的文件是不会导致硬链接运行不了，因为还有别的指着同一内存空间的目录项存在，内存不会释放。

tip：Linux中的文件名和文件内容是分开的，通过文件名去寻找文件内容，所以删除硬链接原本的文件，只是删除了文件名，文件内容仍存在，可以通过硬链接打开。且通过一个文件名球员更改其中的内容，其他文件名访问的内容也会改变。他们有相同的iNode。类似指向相同的内存空间。硬链接数减为0时该文件内容就被删除，即释放内存。

## 8、进程管理命令

### 1、ps au

终端运行的程序

### 2、ps aux

所有运行的程序，任务管理器

### 3、htop

好看动态的显示当前程序运行情况

### 4、who

查看用户在线情况

### 5、进程挂起、后台前台运行、终止

[fg、jobs、&等指令](https://ehlxr.me/2017/01/18/Linux-%E4%B8%AD-fg%E3%80%81bg%E3%80%81jobs%E3%80%81-%E6%8C%87%E4%BB%A4/)

查看用户级后台运行的程序

### 6、查看环境变量

- echo $环境变量名
- env用来显示所有的环境变量





## 9、软件安装与卸载、压缩解压

 ### 1、终端下载

- sudo apt-get install +软件名
- 注意的是选择合适的源

### 2、下载安装包方式下载

- Ubuntu下载的安装包是.deb
- ![1643530921333](./Linux基础学习笔记.assets/1643530921333.png)

### 3、卸载

- sudo apt-get remove 软件名

### 4、源码安装

- ![1643531215059](./Linux基础学习笔记.assets/1643531215059.png)

### 5、压缩解压

![1643545334750](./Linux基础学习笔记.assets/1643545334750.png)



##10、网络管理

### 1、ifconfig

- 查看ip地址

### 2、ping

- 测试网络能否连接上某个ip或域名

## 11、其他命令

### 1、man 

- ![1643543631298](./Linux基础学习笔记.assets/1643543631298.png)
- 查阅命令和函数，文件格式和规范，内核例程

### 2、ctrl+l

- 清屏

### 3、alias

- 用于给命令起别名，类似宏定义

### 4、umask

- 使用权限掩码来创建文件让文件具有一定的权限，注意会去掉可执行权限



## 12、关机与重启

- shutdown
- poweroff：
- reboot：重启

## 13、远程ssh连接

- 使用 ssh  用户名@+ip即可

- 可以配置免密码和配置用户信息封装，可以使用别名进行登录

- 使用scp命令进行数据传输

- ![1644284420144](Linux基础学习笔记.assets/1644284420144.png)

  在Ubuntu下进行ssh连接后，将远程的文件拷贝到Ubuntu本地

- 换种思路就是将需要配置的东西连上window，或者Ubuntu，然后在需要配置的机器上进行远程传输到本地。

- 使用tabby terminal 的STEP进行文件上传更快，且方便。

## 14、补丁命令

![1644995047768](Linux基础学习笔记.assets/1644995047768.png)

## 15、环境变量问题

在/etc/environment中存着PATH，每次启动会加载这个系统环境变量

每次运行bash都会加载~/.bashrc中的信息，可以在其中定义永久的环境变量，比如常用的变量，像工作路径

1 2 4比较比较常用

![1647418240898](Linux基础学习笔记.assets/1647418240898.png)

修改PS1的值可以修改终端中的开头提示符

# Linux基础学习day2

## 1、vi命令（未特殊说明均在命令模式下）

安装neovim：[Ubuntu16.04安装neovim - 简书 (jianshu.com)](https://www.jianshu.com/p/ebd17d53b5c1)

vim插件的安装：[vim极为详细的教程（三）插件的使用 - 哔哩哔哩 (bilibili.com)](https://www.bilibili.com/read/cv6476117/)

vim插件网站：https://vimawesome.com

常用的插件：[多语言编程必备的十大 Vim 插件 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/95596162)

在neovim下安装各种语言调试器：https://github.com/puremourning/vimspector

调试的配置.json：[Vim 最强调试插件：vimspector - 不告诉你我是谁 - 博客园 (cnblogs.com)](https://www.cnblogs.com/kongj/p/12831690.html#%E4%BE%9D%E8%B5%96)

升级python3至3.8：https://cloud.tencent.com/developer/article/1626765

配置为系统默认python3：[(44条消息) 如何将 Ubuntu 16 和 18 上的 python 升级到最新 3.8 版_haiiiiiyun的博客-CSDN博客_ubuntu更新python3.8](https://blog.csdn.net/haiiiiiyun/article/details/104771086?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2.pc_relevant_aa&utm_relevant_index=5)

使用pip3安装![1644053022247](Linux基础学习笔记.assets/1644053022247.png)

==neovim配置过程==

- 首先是基本配置，像快捷键，缩进等，放在配置文件最开始，一些基本的其实可以放后面，插件管理放前面

  键表对应的值和表示：https://blog.csdn.net/JasonDing1354/article/details/45372007

  键盘符号的详细说明，请使用:h key-notation命令查看帮助信息

使用的是镜像进行安装，不知道为什么自己安装总是找不到包，估计是镜像源选取的问题

==------------------------------------------------------nvim中快捷键使用-----------------------------------------------------------------------==

- 使用nvim 进行c/c++调试

  ![1644126474798](Linux基础学习笔记.assets/1644126474798.png)

  快速注释：leader+cc

  删除注释：leader+cu

  全选并复制：ctrl+a

  格式化代码：leader+s

  退出调试窗口：leader+r

  查看当前错误和警告：leader+d

  （快捷键不知道可以去对应插件github上找）

  ​

- 窗口和文件相关

  新建文件：ctrl+n

  打开文件：ctrl+o

  文件另存为：ctrl+s

  缓存区的文件切换视图：space+n：向下

  ​					  space+u：向上

  sp+文件名：有则新建无则打开并水平分屏显示；vsp有则新建无则打开并垂直分屏

  ​

  ​

  切换光标所在窗口：

  | 顺序切换                         | ctrl+ww        |
  | :------------------------------- | :------------- |
  | 左下上右切换，跟移动光标方向一致 | ctrl+w+h/j/k/l |

  ​

- vim-markdown快捷键

  [[ "跳转上一个标题
  ]] "跳转下一个标题
  ]c "跳转到当前标题
  ]u "跳转到副标题
  zr "打开下一级折叠
  zR "打开所有折叠
  zm "折叠当前段落
  zM "折叠所有段落
  :Toc "显示目录（定义为leader+d）

### 1、插入和输入

- i：在光标之前插入
- I：光标移动到行首插入


- a：光标之后插入
- A：光标移动到行末插入
- o：开新的下一行并在行首插入
- O：开新的上一行并在行首插入
- s：删除光标所在字符并插入
- S：删除行并进入插入模式

### 2、退出插入模式进入命令模式

- ESC键

### 3、跳转

- 行号+G：跳转到指定行
- 进入末行模式，输入行号也可以跳转

### 4、gg：跳转到首行

### 5、gg=G：自动格式化程序（缩进）

### 6、%：括号对应匹配跳转

### 7、删除

- x：删除当个字符
- r+字符：将光标所在字符替换
- dw：删除一个单词（前提光标在单词首字母上）
- dd：删除一行
- D：从当前位置删除到行尾（也可以使用d+$）
- d0：删除光标至行首

### 8、光标移动

- 0：移动到行首
- $：光标移动到行尾

### 9、光标移动选择区域

- v：可视化选中，移动光标来选中待操作区域

  后可以执行的操作有 

  1. d：剪切选中区域
  2. y：复制
  3. p：往后粘贴剪切板内容
  4. P：往前粘贴剪切板内容

- ctrl+v实现块可视化，选择要操作的块，并将光标停在需要更改的列，shift+i后输入要插入的字符

  或者删除几个列

### 10、撤销操作

- u：撤销上一步操作，可以撤销多步
- ctrl+r：反撤销

### 11、数字加操作表示该操作重复进行多少次

- 3dd：删除三行

### 12、查找

- /查找内容    
- 按n查找下一处，N查找上一处
- 选中单词后按*（向前）或者#（向后）进行查找单词

### 13、替换

- 单个替换：将光标置于要替换目标所在行，进入末行模式，输入s/欲替换字符串/目标字符串

- 通篇替换：进入末行模式，输入%s/欲替换字符串/目标字符串 /g

  (如果不加最后的/g只替换每一行的第一个)

- 指定行号替换  ：起始行，终止行s/欲替换字符串/目标字符串 /g

### 14、切换到末行模式下

- ctrl+p：呼出上一条历史执行记录
- ctrl+n：呼出吓一条历史执行记录

### 15、分屏

- 末行模式下sp进行横屏分屏，使用ctrl+ww进行切换区域
- 末行模式下vsp进行竖屏分屏，使用ctrl+ww进行区域切换
- 末行模式下wq退出当前区域，并保存，对单块命令还是一样
- 想一次性退出所以得在平时命令加上all

### 16、跳转至man手册进行匹配查询

- 将光标置于想查询的关键字下，按K进行查找，默认查找到第一个
- 如果想查找对应卷的说明，应该按数字+K

### 17、查看宏定义对应的东西

- [+d就会在末行进行宏定义显示

### 18、vim中执行终端命令

- 在末行模式下使用！+终端命令等价与在终端执行该命令
- 执行完看完结果按enter可返回vim下


###==19、==可以配置vim变得好用

- 配置/etc/vimrc（全局）
- 或者在用户目录下面创建隐藏文件.vimrc文件进行配置
- 如果二者均配置，优先使用用户的配置

## 正则表达式

- 符号说明  配合使用管道和grep、sed、awk等命令进行查找



## gcc

### 1、gcc编译四步骤

![1643617500112](./Linux基础学习笔记.assets/1643617500112.png)

![数据段合并](.\Linux基础学习笔记.assets\1643696719078.png)







### 2、常用参数

- -I+头文件路径：用于指定预处理的头文件（如果源文件和头文件在同一目录下不需要指定）

  但是一般会分开存储，并且个人想法是一个项目中将头文件包含到一个总的头文件，每次修改只需要修改该文件，往里面加文件即可，编译时也只需包含这个大的文件

- 每一个命令都包含了前面的几个命令。

- -c：得到二进制文件

- -o ：输出的文件名

- -g：编译时添加调试语句(使代码可以使用gdb进行调试)

- -O+数字：表示优化等级，嵌入式是使用优化0级，因为需要用到一个变量的中间量。

- -Wall：显示所有警告，默认不严重的警告不显示，像定义的变量未使用等

- -D：动态注册一个宏定义，一般用宏作为一个flag，例如写不同板子程序时可以通过宏定义使对应板子的程序进行编译

- -l：指定动态库名

- -L：指定动态库路径

  ​


## 3、静态库和动态库

### 1、静态库

- 每个.c文件需要使用到静态库均得复制一份去编译生成可执行文件，生成的可执行文件会变得很大
- 对空间要求较低，而时间要求较高的核心程序
- 静态库制作步骤：先生成二进制文件（一系列.o文件），然后使用命令ar  rsc lib库名.a  +一些列.o文件路径
- 静态库的使用：和.c文件一起进行编译，库名放在.c文件的后面 库名使用绝对路径

 ### 2、动态库

- 程序运行时去动态库链接函数，但是动态库调用的时间长，调用到了才动态绑定内存地址，延迟绑定，在运行.out文件时调用到动态库的函数才进行内存绑定

- 对时间要求较低，对空间要求较高

- 动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。**不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例**，规避了空间浪费问题。动态库在程序运行时才被载入，也解决了静态库对程序的更新、部署和发布页会带来麻烦。用户只需要更新动态库即可，**增量更新**。

- 动态库的制作步骤：生成与位置无关的代码使用 -fPIC  ，即代码使用的是相对地址，可以加载到内存任意位置

  gcc -c   .c文件名  -o  .o文件名  -fPIC

  gcc  -shared  lib库名.so  +一些列.o文件

- 动态库的使用：编译成可执行文件时，指定所用的动态库 。 -l：指定库名 -L：指定库路径

  gcc .c文件 -o 输出可执行文件名 -l 库名   -L库路径  

  ==注意库名是上面生成的动态库命令中的库名，不包括lib和.so==

  链接器是工作在链接阶段

- **运行可执行文件时还需要动态链接器，它工作与程序运行的阶段，提供动态库所在目录位置**

- 解决方法是提供动态库链接的目录路径：LD_LIBRARY_PATH=动态库路径（==最好使用绝对路径==）

  使环境变量生效，即进行值覆盖:export LD_LIBRARY_PATH=动态库路径

  而且这种环境变量配置只对当前终端有效，重新开启终端需要重新配置

  解决方法是修改配置文件~/.bashrc，配置完保存后记得source  ~/.bashrc 使之生效或者使用.   .bashrc在终端中运行该文件

  还有一种滥竽充数的方法是把动态库放到系统库目录下（/lib），因为每次运行都会动态链接系统库（但是不推荐，因为用户级的东西尽量不要放在系统目录下）

  最后一种方法是修改配置文件

  1. 修改/etc/ld.so.conf   使用sudo vim /etc/ls.so.conf，然后把动态库的绝对路径粘贴进去
  2. 更新查找动态库的路径使配置文件生效  使用 sudo ldconfig -v

- 这种改配置文件的话后续一旦更改库路径的话需要重新配置（个人觉得使用向配置文件写入环境变量并使用相对路径方法更合适，并且保持文件结构不变即可，还有一个方法是把动态库统一放到一个目录下进行管理，路径相对稳定，但是注意还有头文件的问题，源文件使用什么库记得包含头文件）

- 测试程序能否找到动态库的命令 ldd a.out


### 3、动态库和静态库一起使用优先使用动态库






## 4、常见警告

- 隐式声明：编译器在碰到函数时如果没有函数定义和函数声明，编译器会帮你实现隐式声明

  隐式声明默认返回值为int，函数名和参数根据你给的进行

  解决方法是在头文件里进行函数声明，并且包含头文件

  因为一般静态库你也不知道里面具体的函数，静态库在制作的时候应该附带有.h头文件

## 5、常见错误

### 1、预处理

- 缺少头文件

- 重复包含头文件

  可以通过条件编译进行避免

  ![1643684098187](./Linux基础学习笔记.assets/1643684098187.png)

  ​

  ​

### 2、编译

- 主要是检查语法错误，比如未定义变量等

### 3、汇编

- 一般没有错误

### 4、链接

- 找不到链接的函数等


#Linux基础学习day3

## 1、gdb调试工具

- 在使用gcc编译时加上-g（编译时忘记加-g时，可以在进入gdb调试工具后使用file+可执行文件进行加入调试信息）
- gdb + 带调试的可执行文件路径：进入对程序的调试
- 常用指令：
  1. list 1：列出源码，，查看代码行号设置断点
  2. b+行号，设置断点|d +breakpoints NUM：删除断点
  3. r/run：运行程序
  4. n/next：下一步（不进函数），s单步（进函数）
  5. p/print+变量名：查看变量值
  6. finish：结束函数调用，返回函数调用点，即跳出函数
  7. continue：继续执行程序
  8. quit：退出gdb调试
- 其他指令
  1. run：使用run查找段错误出现位置
  2. set args：设置main函数命令行参数/run +字符串1，字符串2...：也可以设置main函数参数并运行
  3. info b ：查看断点信息表
  4. b +行号  if +条件：设置条件断点，一般用于循环语句和递归，当循环变量值为多少时才在对应行停止
  5. ptype+变量名：打印变量类型
  6. bt：列出程序正存活的栈帧（栈帧就是在栈上为每个函数各自开辟的一块存储局部变量和临时值的内存）
  7. frame+数字，切换到不同编号的栈帧中
  8. display+变量名：跟踪变量值   |   undisplay+跟踪变量编号：取消跟踪变量

## 2、Makefile：项目编译管理

### 1、基本原理

- 命名：makefile或者Makefile

- 1个规则：

  ==目标：依赖条件==

  ==（一个tab缩进）命令==

  1. 目标时间必须晚于依赖时间，否则更新目标

  2. 依赖条件如果不存在，寻找新的规则去产生依赖

     （类似递归去找依赖）

  ALL:写在Makefile文件的最开始，指定Makefile要生成的最终目标文件，如果没有ALL，默认第一个目标为最终目标

  tip：这里的命令即为终端执行的命令，比如gcc -o hello.o -c 

  ​	目标为文件名，依赖条件为提供的编译文件路径

- 2个函数：

  src=$（wildcard ./*.c）:提取当前工作目录下的所有.c文件名，将文件名组成列表赋值给src

  obj=$（patsubst %.c，%.o，$（src））：将参数3中的，包含参数1的部分，替换为参数2,并形成一个列表赋值给obj。

  tip：$(变量名)是取出变量值

  clean没有依赖，用于执行删除文件，命令最开始加上-是当文件不存在时不报错

  clean:
          -rm -rf $(obj) a.out

  ​

- 3个自动变量：

  $@：在规则命令中，表示规则中的目标。

  $^：在规则的命令中，表示所有的依赖条件。

  $<：在规则的命令中，表示第一个依赖条件。如果将该变量运用在模式规则中，它可将依赖条件列表中的依赖依次取出，套用模式规则：

  ​	%.o:%.c

  ​		gcc -c  $<   -o  %@

  静态模式规则：

  ​	指明该规则专门给生成obj的时候用（即在使用模式规则生成obj时寻找的是.c文件）

  ​	$(obj):%.o:%==.c==

  ​		gcc -c  $<   -o  $@

  ​	指明该规则专门给生成obj1的时候用（即在使用模式规则生成obj时寻找的是.s文件）

  ​	$(target):%.o:%.s

  ​		gcc -c  $<   -o  $@

- 伪目标：(不用生成该文件，但是要去执行下面的命令，防止当前目录有跟clean和ALL重名的文件，会包已经是最新了的错误)

  .PHONY:clean ALL

  学会自定义变量

  args=字符串

  使用变量时$(args)即可类似宏替换

- 参数

  -n：模拟执行make、make clean命令，防止出错删错东西

  -f：指定文件执行文件名非makefile/Makefile的makefile文件，如果Makefile文件文件名为Makefile就不需要指定该参数

- 如果有多个可单独运行的.c文件在一个文件夹下（多个main函数），可以使用静态模式规则创建多个可执行文件，，即终极目标为多个文件，定义目标变量ALL：$(target)

  （==多个.c文件编译的话，一个可执行文件一个makefile==）

 # Linux基础学习day4

## 1、文件IO

### 1、系统调用

- 系统调用就是通过内核与底层硬件打交道，实现底层调用，主要是学习系统调用的函数
- ![1643949664510](Linux基础学习笔记.assets/1643949664510.png)
- ​

###2、open()/close()函数

1. open（）函数

   - 有哪几个形参数和参数有哪些取值看手册，并且需要记忆，返回值（出错返回-1）

   - 三个参数分别为，操作的文件路径，方式，新创建的文件权限（文件权限指定时受umask影响为mode&（~umask））。==参数的宏定义在头文件<fcntl.h>中==

   - 常见错误，打开不存在的文件、以只写方式打开只读文件，以只写打开一个目录而不是文件

   - ![1643870001652](Linux基础学习笔记.assets/1643870001652.png)

     ​

2. close（）函数

   - int close(int fd);

3. ![1643873631007](Linux基础学习笔记.assets/1643873631007.png)

   ​

   ​

### 3、read和write函数

1. ![1643876606186](Linux基础学习笔记.assets/1643876606186.png)

   ![1649037169535](Linux基础学习笔记.assets/1649037169535.png)

   ​

   ​

2. 直接使用read 和write一次写一个字节比使用fgetc和fputc相比慢的原因

   用户字节设定缓冲区为4096字节可以最快提高速度

   预读入缓输出，先暂存，凑多点再一起送过去，避免次数过多的资源消耗

   ![1643874322021](Linux基础学习笔记.assets/1643874322021.png)

   ​

3. 学了系统调用函数后，还是优先使用库函数，因为自己还是不了解系统调用函数的执行机制

   但是当库函数逻辑满足不了需求时，应该使用系统调用实现，比如不需要一次性读写4096字节

### 4、文件描述符

- PCB进程控制块：本质  结构体

- 成员：文件描述符表

- 文件描述符：0、1、2...1023  表中最小的可用

  0-STDIN_FILENO

  1-STDOUT_FILENO

  2-STDERR_FILENO

- ![1643875958739](Linux基础学习笔记.assets/1643875958739.png)

### 5、阻塞和非阻塞：阻塞是文件的属性

- 产生阻塞的场景。读设备文件（像键盘，等待输入）。读网络文件（读常规文件无阻塞概念）
- /dev/tty ----终端文件
- open("/dev/tty",O_RDWR|O_NONBLOCK)  ----设置非阻塞打开终端终端（默认为阻塞状态）

### 6、fcntl函数

该函数可以更改标准输入设备（键盘）为非阻塞，就不用使用open打开终端设定为O_NONBLOCK

函数原型为int (int fd,int cmd,...);不同的cmd参数，后面有不同的设置参数

int flags =fcntl(fd,F_GETFL);

flags|=O_NONBLOCK

fcntl(fd,F_SETFL,flags);

获取文件状态：F_GETFL

设置文件状态：F_SETFL

(获取flags和修改flags)

### 7、lseek函数

- 函数原型：off_t lseek(int fd, off_t offset, int whence);

- 参数：

  fd：文件描述符 

  offset：偏移量

  whence：起始偏移位置（SEEK_SET/ SEEK_CUR/ SEEK_END）

- 返回值：

  成功返回较起始的偏移量

  失败返回-1 设置errno

- 应用场景：

  - 文件读写使用同一偏移量，比如写完文件进行读文件内容应使用lseek进行偏移再进行读

  - 使用lseek获取（把光标偏移到最后获取返回值即可）

  - 拓展文件大小：要想使文件大小真正拓展，必须引起IO操作，即要写入东西。

    可以使用truncate函数，直接拓展文件 int ret =truncate("文件路径"，拓展字节数)

 ### 8、传入传出参数

![1643897111859](Linux基础学习笔记.assets/1643897111859.png)

==指针作为函数参数充当函数返回值，本质就是改值并且不会在块内销毁==



## 2、文件系统

### 1、文件存储

- 目录项：包含文件名和inode，建立文件硬链接就是创建新的文件名和inode，多个文件均指向同一个inode结构体，里面包含文件属性等、其中有存储了对应的磁盘存储信息。

### 2、stat函数

- 函数原型： int stat(const char *pathname, struct stat *buf);

  参数：

  path：文件路径

  buf：传入传出参数作为缓存区

  返回值：

  成功：0

  失败：-1   设定errno

  获取文件大小：buf.st_size

  获取文件权限和类型的一个变量：buf.st_mode

  获取文件类型：buf.st_mode（将该参数传入给宏）

- 有一些宏函数可以进行文件类型的判断

  ![1643942547754](Linux基础学习笔记.assets/1643942547754.png)

  ​


### 3、lstat函数

与lstat的区别就是stat会穿透符号链接，lstat不会（在判断软链接是什么文件类型时穿透是会返回链接的源文件的类型）

### 4、其他简单操作文件函数

- access函数：获取访问权限属性
- chmod函数：修改访问权限
- truncate函数：拓展或截取文件大小
- readlink函数：读符号链接文件本身内容，得到链接文件的路径
- rename函数：重命名，跟实现mv类似，新建硬链接，删除旧的硬链接（目录项）

###5、在程序中将文件硬链接数减为零，仍然可以进行读写操作，实际写到缓冲区

文件硬链接数变为0，若还有进程打开该文件，该内存资源不会被释放，操作系统在程序结束会自动回收内存空间

![1644140051459](Linux基础学习笔记.assets/1644140051459.png)



### 6、目录操作

#### 1、函数

- getcwd函数：获取当前工作路径


- chdir函数：改变工作目录   

- DIR * opendir(char *name)函数：进入目录

- int closedir(DIR *dp)函数：关闭目录

- struct dirent * readdir( DIR *dp)函数：读取目录，有类似获取文件属性的函数lstat的功能

  读出了一个目录项，常用成员为d_name[256],目录名为一个静态数组，可见目录名最长为255字节

####2、文件目录权限![1643946529520](Linux基础学习笔记.assets/1643946529520.png)

### 7、实现ls -R

- 关键点：实现读目录，是目录先打印，在读目录中进行是否是文件判断并打印并递归调用读目录函数

  容易出问题是因为含有 “.”这个目录，会进入一个循环调用“.”。需要单独判断跳出。

- ![1644148872910](Linux基础学习笔记.assets/1644148872910.png)

### 8、重定向

-  函数原型：int dup(int oldfd); 

  oldfd：旧文件描述符

  返回新的文件描述符 

  作用是产生一个文件副本，是一个拷贝，对该文件描述符的操作会引起改变，一起共用一个内存空间

- int dup2(int oldfd, int newfd);  ==实现重定向输出==

  （ 3  dup2  4  ，改4会影响3；即两个文件描述符是指向原本三指向的内存。）

  本质是返回newfd，可以对旧文件进行直接操作，对两个文件描述符进行读写均会改变oldfd所指的内容。

- fcntl函数实现dup2的功能   ==fcntl这个函数比较万能，根据cmd的不同，再传不同参数，实现不同功能==

  cmd：D_DUPFD

  参3：被占用，返回最小可用的文件描述符，未被占用的即返回参3的值

# Linux基础学习day5

## 1、进程（查看进程ps aux）

- 程序：死的。只占用磁盘空间  --剧本。
- 进程：活的。运行起来的程序，占用内存、cpu系统资源。 --戏
- 并发：开始是并发是分时复用。类似动态数码管，但是由于频率过快，看起来就像是并行的。

## 2、虚拟内存和物理内存的映射关系

- 除了内核段外，其余是通过CPU上的一个叫MMU（内存管理单元）的进行虚拟映射，把不连续的物理地址映射成为逻辑上连续的内存，MMU相当于帮你排序成连续的数据，但这个映射关系是自己储存

- 内核段是共享的，操作系统只有一个

- 解释图

  ![1644241021875](Linux基础学习笔记.assets/1644241021875.png)

- 进程结构体 struct task_struct 

  在头文件/usr/src/linux-headers-4.15.0-142/include/linux/sched.h 下面定义的

  重点掌握

  ![1644242370892](Linux基础学习笔记.assets/1644242370892.png)

  环境变量：命令env可以查看

  查找的PATH：使用echo$PATH可以打印环境变量

    SHELL：命令解释器（脚本），通常是/bin/bash（其实还有sh）

  - 切换默认shell的命令为 ：chsh -s  +shell的可执行文件路径 ==（需要重新启动才生效）==

## 3、fork函数

在fork（）函数后产生子进程，成功返回，子进程的fork函数返回0，父进程返回子进程的pid

fork（）函数产生多个子进程后，得想办法让子进程不利用后序代码进行创建孙子进程，可以利用返回值来阻止其创建，同时，使用for循环创建时，后面会争资源去运行程序，取决于内核所使用的调度算法。

![1644290094418](Linux基础学习笔记.assets/1644290094418.png)

输出结果一秒打一个，可见是同时产生的，不同的子进程sleep时间不同，每个按顺序间隔1秒

父进程和所以子进程遵循读时共享写时复制的原则。只要进行写操作，就会复制一份。全局变量一样会复制一份，不是共享的。

![1644290803245](Linux基础学习笔记.assets/1644290803245.png)

![1644290946034](Linux基础学习笔记.assets/1644290946034.png)

![1644310571966](Linux基础学习笔记.assets/1644310571966.png)

## 4、exec函数族

![1647276453147](Linux基础学习笔记.assets/1647276453147.png)

![1644312713252](Linux基础学习笔记.assets/1644312713252.png)

此处子进程调用的函数，传入的第一个参数为argv[0]，所以在调用时记得，把path或file作为第一个arg参数。

==执行exec成功的话就直接跑exec中调用的程序了，原本程序后续的代码都作废，可以用来做错误处理的事情。==

![1644314144622](Linux基础学习笔记.assets/1644314144622.png)

重新加载环境变量指定可执行文件的路径

## 5、回收子进程

![1644320209136](Linux基础学习笔记.assets/1644320209136.png)

僵尸进程是指子进程结束后，父进程还在执行，此时init不会领养子进程进行残留资源回收，需要kill父进程，二者才会一起结束。或者父进程调用wait函数，阻塞等待子进程死亡将其回收再继续执行，可以使用宏函数查看wait的传入参数，进而判断子进程的结束状态。如果不关心子进程的终止状态，则传入参数为null。

![1644325804652](Linux基础学习笔记.assets/1644325804652.png)

![1644325776737](Linux基础学习笔记.assets/1644325776737.png)



![1647276972751](Linux基础学习笔记.assets/1647276972751.png)

![1644326267006](Linux基础学习笔记.assets/1644326267006.png)

==一次调用只回收一个子进程，清理多个使用循环==

父进程可以进行子进程的回收。

- 命令ps aux查看当前系统进程
- ps ajx查看父子进程pid 


## 6、进程间通信

![1647268609904](Linux基础学习笔记.assets/1647268609904.png)

### 1、管道 

![1647273349245](Linux基础学习笔记.assets/1647273349245.png)

==fd为文件描述符，传出参数==

![1647276282986](Linux基础学习笔记.assets/1647276282986.png)

pipe函数是创建并且打开管道

![1647275420467](Linux基础学习笔记.assets/1647275420467.png)



demo：子进程实现将ls标准输出重定向到管道，并使用父进程执行wc-l +（从管道获取的结果），并输出到标准输出。

tips：可以多个写管道，一个进行读管道。使用ulimit -a 查看管道缓冲区大小

![1647353859687](Linux基础学习笔记.assets/1647353859687.png)

- FIFO：有名管道

  可用于无血缘关系的进程之间的管道通信

  操作就是读写文件，一边以只写方式往FIFO中写，另一边以只读方式往FIFO中读。

  可以多个读端多个写端




## 7、共享存储映射

### 1、文件通信

- 无血缘关系的两个进程可以通过文件进行进程间通信，但是得掌握好时序和光标位置，记住是无阻塞的

### 2、存储映射IO

-        void *mmap(void *addr, size_t length, int prot, int flags,
                    int fd, off_t offset);

![1647591074513](Linux基础学习笔记.assets/1647591074513.png)

注意事项 ：指定的映射存储区大小不能大于文件大小（总线错误），文件大小不能为0（无效参数）

用于创建映射区的文件属性为只读，映射区为读写。

使用扩展文件大小的函数需要写权限，创建映射区的过程调用mmap需要读文件

访问权限指定为MAP_SHARED时，mmap的读写权限<=文件的open的权限（至少需要读权限）

文件描述符fd，在mmapp创建映射区完成即可关闭，后续不需要用到它。

offset必须是4096的整数倍（MMU最小映射为4k）

MAP_PRIVATE是对映射区的内存进行读写，不对磁盘操作，所以权限不需要（mmap的读写权限<=文件的open的权限），文件打开可以只读，因为mmp需要读fd，而mmp中权限看自己情况需要。

![1647604448098](Linux基础学习笔记.assets/1647604448098.png)

![1647606439521](Linux基础学习笔记.assets/1647606439521.png)

![1647606703407](Linux基础学习笔记.assets/1647606703407.png)

无需创建文件和关闭文件，fd传入-1占位

tips：Linux系统下，/dev/zero是一个任意大小的空洞文件，均为为\0

​				/dev/null是一个无限大小的黑洞，可以丢任何东西进去



## 8、信号

- 简单、不能携带大量信息、满足条件才发送。

- 信号的机制：软件层面的“中断” ，每个进程收发信号都是内核负责发送的，内核处理

- 与信号相关的事件和状态![1647612591409](Linux基础学习笔记.assets/1647612591409.png)

  ![1647612833748](Linux基础学习笔记.assets/1647612833748.png)

  ![1647613512654](Linux基础学习笔记.assets/1647613512654.png)

  ![1647613694061](Linux基础学习笔记.assets/1647613694061.png)

  信号4要素：名称、编号、对应的事件、默认处理动作 

  常用信号是前20个

  ![1647655570326](Linux基础学习笔记.assets/1647655570326.png)

  alarm每次调用返回上次调用到现在剩余的定时时间，传入0作为参数会将闹钟取消

  kill函数（本质就是一个发送信号的函数，主要是用来让内核杀死进程的）

  ![1647673294155](Linux基础学习笔记.assets/1647673294155.png)

  signum是指待发送的信号（可以是编号和名称）

  ​

  setitimer函数（可以更精细的设置定时时间，并且可以选择计时是自然时间还是用户时间，或者是内核+用户计时时间，注意的是参数为结构体变量，一个为传入参数，一个为传出参数）

  ![1647674522126](Linux基础学习笔记.assets/1647674522126.png)

- 信号集操作

  ![1647675856880](Linux基础学习笔记.assets/1647675856880.png)



**==信号捕捉是重点==**

 signal函数：用来注册一个信号捕捉函数，捕捉此信号并执行自己传入的函数（自定义函数）

 sigaction函数： 

```
       int sigaction(int signum, const struct sigaction *act,
                     struct sigaction *oldact);
```



![1647694693625](Linux基础学习笔记.assets/1647694693625.png)

信号捕捉特性：

- 1、捕捉函数执行期间，信号屏蔽字由mask-》sa_mask，捕捉函数执行结束，恢复回mask

  2、信号捕捉函数期间，本信号自动被屏蔽（前提是sa_flgs = 0）

  3、捕捉函数执行期间，被屏蔽信号多次发送，解除屏蔽后只处理一次（因为未决信号只能记录一次）

内核实现信号捕捉的过程：需要有进入内核的机会（中断、异常、系统调用），类似FreeRTOS中的任务切换

在内核处理完异常后准备返回用户模式前处理可以递送的信号，如果信号处理动作为自定义则回到用户模式执行信号处理函数（如果不是自定义 ，内核直接进行处理），还需返回到信号处理函数处（内核），最后再返回用户模式进行向下执行。

![1647694143453](Linux基础学习笔记.assets/1647694143453.png)

- 利用信号回收原本可能回收不了的子进程（注意父进程不能先结束，不然注册函数会被回收了）

  ![1647696200521](Linux基础学习笔记.assets/1647696200521.png)

  ![1647696178677](Linux基础学习笔记.assets/1647696178677.png)

  ​

  ![1648635413769](Linux基础学习笔记.assets/1648635413769.png)![1648635455479](Linux基础学习笔记.assets/1648635455479.png)阻塞和解除阻塞是防止信号捕捉函数还没注册完，已经有子进程回收了，发来了信号，和自己预想的操作不符，所以先阻塞了子进程死亡的信号，后面注册完再进行处理。

- 慢速系统调用

  造成阻塞的系统调用

  如果中间等到了一个信号，被信号处理中断了，这肯定是打断了原本阻塞的逻辑，所以需要在处理完信号后让这个阻塞重新启动，通过对信号的设置可以做到，在调用信号处理函数 sigaction函数时sa_flag传入SA_RESTART即可，后续慢速系统调用被该函数信号捕捉函数中断后可以得到重新启动，默认是不重启的。


## 9、进程组和会话

![1648648636903](Linux基础学习笔记.assets/1648648636903.png)



- 创建会话

![1648648061428](Linux基础学习笔记.assets/1648648061428.png)

![1648648504492](Linux基础学习笔记.assets/1648648504492.png)

![1648648202412](Linux基础学习笔记.assets/1648648202412.png)

 ## 10、守护进程

![1648649348283](Linux基础学习笔记.assets/1648649348283.png)

![1648649473727](Linux基础学习笔记.assets/1648649473727.png)

- 守护进程创建步骤：![1648649984153](Linux基础学习笔记.assets/1648649984153.png)

  更改工作目录是为了防止守护进程的工作目录被卸载，改变工作目录到不会被卸载的位置

  关闭文件描述符是关闭标准输入，重定向标准输出和标准错误输出，因为守护进程没有终端，防止误操作

![1648651194366](Linux基础学习笔记.assets/1648651194366.png)



![1648651620566](Linux基础学习笔记.assets/1648651620566.png)

- 线程与进程的区别（红字有误，看下面一条）

![1648652036447](Linux基础学习笔记.assets/1648652036447.png)

## 11、线程

![1648652120078](Linux基础学习笔记.assets/1648652120078.png)

进程：有独立的进程地址空间。有独立的PCB ，且三级映射不同，所以会有独立的进程地址空间，分配资源的最小单位

线程：是最小的执行单位，一个进程创建成多个线程后，这几个线程共同参与CPU调度，有独立的PCB，但PCB中的三级映射相同。没有独立的进程地址空间

**命令**：ps  -Lf  进程号  可查看线程号  LWP是CPU执行的最小单位。

![1648689730187](Linux基础学习笔记.assets/1648689730187.png)

线程独有的资源是寄存器和栈（内核栈和用户栈），类似FreeRTOS中任务的概念

![1648689970513](Linux基础学习笔记.assets/1648689970513.png)

![1648690022458](Linux基础学习笔记.assets/1648690022458.png)

###1、线程控制原语

- 获取线程ID，该ID用于标识线程身份的ID号：使用pthread_t  pthread_self(void)；
- 创建线程：   

int pthread_create(pthread_t *thread, const pthread_attr_t *attr,   void *(*start_routine) (void *), void *arg);

创建多个线程 

![1648731833100](Linux基础学习笔记.assets/1648731833100.png)

- 将当前线程退出：void pthread_exit(void *retval);  ==注意如果使用exit(0);是退出当前进程，所有的线程都会结束==

- 回收线程： int pthread_join(pthread_t thread, void **retval);    默认阻塞回收子线程

  retval为传出参数，自己提前定义，因为退出参数为一级指针，作为传出参数必须就为二级指针

  ![1648733789513](Linux基础学习笔记.assets/1648733789513.png)

  ​

- 线程分离就是当线程被设置为分离状态后，线程结束时，它的资源会被系统自动的回收，而不再需要在其它线程中对其进行 pthread_join() 操作。我们使用默认属性创建一个线程的时候，线程是 joinable 的。 joinable 状态的线程，必须在另一个线程中使用 pthread_join() 等待其结束，如果一个 joinable 的线程在结束后，没有使用 pthread_join() 进行操作，这个线程就会变成”僵尸线程”。每个僵尸线程都会消耗一些系统资源，当有太多的僵尸线程的时候，可能会导致创建线程失败。
  ​

  ![1648737433698](Linux基础学习笔记.assets/1648737433698.png)

- 设置线程初始创建的属性为分离状态，使用系统提供的函数接口，初始化属性，并修改属性，最后销毁前面初始化属性的指针

  ![1648745790072](Linux基础学习笔记.assets/1648745790072.png)

  不做错误检查可以比较明显看出逻辑

  ![1648746579584](Linux基础学习笔记.assets/1648746579584.png)

- 杀死线程：int pthread_cancel(pthread_t thread);  被pthread_cancel杀死的线程返回-1，使用pthread_join对僵尸线程进行回收 

  ==需要有进内核的契机才能将线程杀死，如果整个线程的执行过程 都没有进入内核，则pthread_cancel得不到执行，此时可以通过调用pthread_testcancel()添加一个进内核的契机==

tip：回收和终止不太一样，终止是无条件停止，回收是有条件的停止，可以阻塞等待回收等。

- 在线程中检查出错返回的错误号，需要配合使用strerror();函数将错误号转换为错误信息

  使用fprintf(stderr，“xxx error：%s\n”，strerror(ret));（使用perror("")）

### 2、进程和线程控制原语对比

![1648744068903](Linux基础学习笔记.assets/1648744068903.png)

### 3、使用线程的注意事项

![1648746694362](Linux基础学习笔记.assets/1648746694362.png)

  # Linux基础学习day6

## 1、线程同步

- 一些学习的文章：

[线程同步的几种方式 - sherlock_lin - 博客园 (cnblogs.com)](https://www.cnblogs.com/sherlock-lin/p/14538083.html)



![1648776810177](Linux基础学习笔记.assets/1648776810177.png)

![1648777101788](Linux基础学习笔记.assets/1648777101788.png)

 ## 2、互斥量\互斥锁 mutex（建议锁）

### 1、建议锁

在访问互斥量前先拿锁，成功加锁后才能操作互斥量，但是不是强制要求，只是提供该机制实现互斥访问

![1648808823481](Linux基础学习笔记.assets/1648808823481.png)



###2、使用方法

![1648817073401](Linux基础学习笔记.assets/1648817073401.png)

restrict关键字：限定指针，指定某内存空间（即变量）只能由该指针进行内存操作，不能通过除该指针外所有其他直接或间接的方式修改该对象的内容

  ## 3、读写锁

读写锁只有一把，只是加锁的方式不同

![1648817350192](Linux基础学习笔记.assets/1648817350192.png)

![1648817230024](Linux基础学习笔记.assets/1648817230024.png)

tip：就是写时只能一个线程在写，读可以多个线程同时读且不能写。当有一个在写，其他同时来的有读也有写，此时不是读共享，因为读完马上就被同时来的写给改了，所以此时是写优先，读继续堵塞，写完再读

![1648902379192](Linux基础学习笔记.assets/1648902379192.png)



- 使用锁不恰当导致的现象：自锁和互锁，还有震荡（哲学家吃面问题）

![1648817546254](Linux基础学习笔记.assets/1648817546254.png)

## 4、条件变量

- 本身不是锁，但通常结合锁来使用。 mutex 

  ![1648820194290](Linux基础学习笔记.assets/1648820194290.png)

![1648820339541](Linux基础学习笔记.assets/1648820339541.png)

![1648821070292](Linux基础学习笔记.assets/1648821070292.png)

- 条件变量使用步骤：

  ![1648821512029](Linux基础学习笔记.assets/1648821733619.png)

- 条件变量实现生产者消费者模型：一个线程生产数据，另一个线程消费数据【重要】

  ![1648881503475](Linux基础学习笔记.assets/1648882408811.png)

  下面说明即使wait出来后拿到了锁，也得再一次判断共享数据区非空才能进行数据访问

  ![1648881530854](Linux基础学习笔记.assets/1648882377784.png)

  条件变量唤醒阻塞在条件变量上的进程的函数：

  ![1648882537693](Linux基础学习笔记.assets/1648882537693.png)

## 5、信号量（可用于进程和线程）

类似FreeRTOS中的计数信号量

- 初始化值为N的互斥量。N值，表示可以同时访问信号量的线程数。
- 使用信号量实现生产者消费者模型（数据使用队列进行模拟），二者关注信号的方式不同。

![1648884658774](Linux基础学习笔记.assets/1648884658774.png)

生产者：wait生产数据并通知消费者，生产前检查数据区是否满了

![1648884868431](Linux基础学习笔记.assets/1648884868431.png)

消费者：wait消费数据并通知生产者生产数据

![1648884925778](Linux基础学习笔记.assets/1648884925778.png)

## 6、文件锁

- 同样的，文件锁也是读时共享，写时独占，与读写锁相同

  但是文件锁只能用于进程间，线程间无法使用，因为文件加锁是通过修改文件描述符所指向的文件结构体中的成员变量实现，而线程间文件结构体是共享的，无法单独修改。（线程间使用读写锁进行）

![1648900998597](Linux基础学习笔记.assets/1648900998597.png)

![1648901234842](Linux基础学习笔记.assets/1648901234842.png)

# Linux基础学习day7

网络编程：

## 1、协议

TCP协议注重数据的传输。http 协议着重于数据的解释。

![1648952353341](Linux基础学习笔记.assets/1648952353341.png)

![1648952379326](Linux基础学习笔记.assets/1648952379326.png)





![1648904019389](Linux基础学习笔记.assets/1648904019389.png)





## 2、网络应用程序设计模式

![1648952406436](Linux基础学习笔记.assets/1648952406436.png)



1. C/S模型

   客户端和服务器端，客户端位于目标主机上，将数据缓存到客户端本地，使用在数据量较大，所采用的协议相对灵活，要求稳定的场景下

2. B/S模型

   借助浏览器作为客户端，只需要开发服务器端，降低开发难度，但数据传输较小，无法预先缓存，使用在数据量较小的场景下

## 3、分层模型

OSI七层模型

![1648953841967](Linux基础学习笔记.assets/1648953841967.png)

![1648955462614](Linux基础学习笔记.assets/1648955462614.png)

- 物理层：物理传输设备，线路光纤，电平
- 数据链路层：帧，将物理层电平进行封装，并进行校验什么的（可以自定义协议，收发双方解读数据一致即可）
- 网络层：在路由之间进行传输数据，主要使用APR在各节点的路由器之间传输（中间没帧传输的数据可以使用自定义协议）
- 传输层：传输到对应的IP主机后，一个主机上面的进程有多个，需要确定是那个进程发送和接收，需要封装收发的端口号
- 应用层：

## 4、数据包封装

数据传输必须得封装。

==最终一次传输的最大数据量取决于每一层协议所能容纳的数据量，并不是越大越好，因为可见在TCP传输协议可见，可能会发生丢包，所以拆包可以避免因为丢包重传损失过多的发送效率。==



![1648954436418](Linux基础学习笔记.assets/1648954436418.png)

数据在网络中的传输，借助路由网路，且在数据包中封装了目标IP，根据目标IP进行寻路（TCP记录第一次寻路路径，每次传输都是同个路径，而UDP则每次都会重新寻路）

![1648987871292](Linux基础学习笔记.assets/1648987871292.png)



##5、以太网帧格式（数据链路层）

==首先是解网络层获取最终以太网目的IP，并一直通过数据链路层的ARP进行传输下去，最后找到目标IP，目标IP主机收到源IP请求后，发送ARP应答将硬件地址发送过去。==

逐层封装，到网络传输层时，网络由路由器节点组成，每个路由器节点都有自己连接上的路由器表，可以传输下去，传输前需要寻路，是通过以太网帧协议中的ARP类型进行传输，ARP中存有目标地址和源地址还有接受端的IP每经过一个路由器节点都会进行解包并将接收端ip与自己比对，不是自己的ip就继续向下传输。（经过中间n个路由器节点都是进行解包查看ip并重新封包，改了目的mac和源mac 并进行传输）

![1648957023095](Linux基础学习笔记.assets/1648957023095.png)



![1648956867260](Linux基础学习笔记.assets/1648956867260.png)

ARP的作用是通过IP地址获取MAC地址

NAT映射：也很好的理解了公网IP段数目少，但却可以满足巨大数量的终端主机网络传输的需求。![1648966837504](Linux基础学习笔记.assets/1648966837504.png)

## 6、网络层

![1648965922866](Linux基础学习笔记.assets/1648965922866.png)



TTL生存时间是防止包在网络层循环传输次数过多且没有到目的主机，而设置的传输结果路由器的次数，数据包每经过一跳TTL减一，为0时进行包丢弃。

![1648960705199](Linux基础学习笔记.assets/1648960705199.png)

## 7、传输层（操作系统帮忙封装，16位端口）

![1648964884137](Linux基础学习笔记.assets/1648964884137.png)

![1648964988382](Linux基础学习笔记.assets/1648964988382.png)

   ## 8、打洞机制

![1648972460180](Linux基础学习笔记.assets/1648972460180.png)

局域网内类似公对公，因为有在同一个映射表存着局域网中的两个主机的局域网IP。

![1648972252451](Linux基础学习笔记.assets/1648972252451.png)

## 9、socket--套接字

![1648972906207](Linux基础学习笔记.assets/1648974238610.png)

- socket成对出现
- 确定端口号和IP
- 一个socket文件描述符，两个缓冲区，一个读缓冲，一个写缓冲

### 1、预备知识

- 大小端存储

![1648974630172](Linux基础学习笔记.assets/1648974630172.png)

- 网络字节序和IP地址转换函数

  ![1648974994340](Linux基础学习笔记.assets/1648974994340.png)

  下面是实现字符串转网络字节序的库函数

  ![1648988464499](Linux基础学习笔记.assets/1648988464499.png)

  ​

- sockadd数据结构（man 7 ip 可以查看其结构体成员）

  ![1648977795346](Linux基础学习笔记.assets/1648977906724.png)

- MUS：最大的传输上限，受协议限制

  mss:除去协议头

  win:本端能接受的数据上限

- ![1649053287818](Linux基础学习笔记.assets/1649053287818.png)

### 2、网络套接字函数





### 3、C/S模型典型流程图

客户端没有bind绑定端口号和ip是因为自动生成了（也可以加一个bind固定地址和端口号），而服务器端需要绑定IP和端口号是为了客户端能够找到其IP和端口，与其进行连接

![1648978715033](Linux基础学习笔记.assets/1648978715033.png)

### 4、C/S实现代码



头文件：

![1648990570866](Linux基础学习笔记.assets/1648990570866.png)

==下面代码还需要添加错误提示，可以将库函数封装成成带错误提示的再调用==

慢速系统调用阻塞被中断后需要重启

![1649036495814](Linux基础学习笔记.assets/1649036495814.png)





服务端代码：

服务器开始创建套接字是为了能让客户端连上，后面的接收到的套接字用于连接和双向传输

![1648980966288](Linux基础学习笔记.assets/1648980966288.png)

客户端代码：

![1648990539565](Linux基础学习笔记.assets/1648990539565.png)





- 读文件100字节

  一次my_read读到100个字节，在没有将读到的字节全部输出到传出参数ptr中是不会进入if进行下一个100字节的读取，而且是变量是静态的，所以在下一次调用时会把原本读了还剩的数据送出，也就是用在下面的读一行，要是read_cnt没减到0是不会再读100字节的（静态变量在此起到了记忆字节数的功能）

  ![1649039237997](Linux基础学习笔记.assets/1649039237997.png)

- 读一行，同时也实现读一定长度为一个串

  ![1649039274949](Linux基础学习笔记.assets/1649039274949.png)

## 10、TCP协议

![1649042917244](Linux基础学习笔记.assets/1649042917244.png)

![1648964988382](Linux基础学习笔记.assets/1648964988382.png)



### 1、三次握手（总共发送三次数据）

![1649043264542](Linux基础学习笔记.assets/1649043264542.png)

### 2、传输数据

![1649044672492](Linux基础学习笔记.assets/1649044672492.png)

==在建立连接或者断开连接时需要在原本的包号基础上+1个标志位SYN或者FIN==

在建立连接后，在开始发送的包号后继续往后编号，包号为当前的字节标号，比如上面的三次握手后客户端的发送包号应从1001开始（因为SYN占一个字节），并在包号后的括号中加上发送的数据字节数，而服务器端类似的从8001开始

### 3、四次挥手

![1649045285232](Linux基础学习笔记.assets/1649045285232.png)

允许只有一端关闭，要关闭的一端发起FIN请求，收到ACK后进入半关闭状态，此时还能接收对端发来的数据，并且做应答，但是无法主动发送数据。



###4、建立连接和断开连接的示意图

![1649045180915](Linux基础学习笔记.assets/1649045180915.png)

### 5、TCP异常断开与重连

- 心跳包：处于应用层的协议，用于判断网络连接是否断开
- 乒乓包：简单数据传输，像判断有没有等此类简单数据
- 探测分节：现在基本不用，时间过长，等待过久

## 11、高并发服务器

### 1、多进程版的并发服务器

服务端代码思路：

1. 创建socket套接字lfd
2. bind  IP和端口号
3. listen 设置同时申请连接的上限数，linux中有上限128
4. accept 阻塞等待连接，得到连接后返回与客户端通信的套接字 cfd
5. 此时需要fork子进程，通过fork返回值进行判断，并进行错误处理和父子进程业务分别写；父进程关闭cfd，子进程关闭lfd，父进程负责等待客户端连接，子进程和每个连接的客户端进行业务处理。子进程可以通过break跳出while并进行子进程业务处理。
6. 父进程业务中需要注册信号函数，传入子进程状态改变的信号，并实现回调函数，在回调函数中进行结束的子进程的回收，回调函数中使用while循环调用waitpid（）实现可以一次回收多个；

### 2、多线程版的并发服务器

==可以用于管理多个客户端，实现一个类似上位机的功能==

服务器代码思路：

1. 创建socket套接字lfd

2. bind  IP和端口号

3. listen 设置同时申请连接的上限数，linux中有上限128

4. 与进程不同的可以创建一个存储一个封装有 accept连接上的套接字文件描述符和客户端的地址信息（下面的结构体），每个线程对应处理数组中对应的下标的套接字的客户端的东西。传参只需传对应下标的结构体

   ```
          struct sockaddr_in {
              sa_family_t    sin_family; /* address family: AF_INET */
              in_port_t      sin_port;   /* port in network byte order */
              struct in_addr sin_addr;   /* internet address */
          };
   ```

5. 线程创建后需要进行分离，脱离主线程的管控，在结束由系统自动回收

![1649052656964](Linux基础学习笔记.assets/1649052656964.png)



==以上两种高并发服务器对CPU的消耗较大，在客户端数据量不是很大时可以采用==







## 12、实现远程服务器作为服务端

本地电脑为客户端进行连接，进行服务端代码编写

==要连接上公网IP必须要服务器开放对应所使用的端口。==

要实现任意设备通过ssh或其他方式（其他程序的IP和端口）访问局域网IP

使用FRP实现反向代理（内网穿透），实际上是局域网本地ssh端口连接到远程服务器，并在服务器上开一个端口作为转发，使局域网IP在公网有一个端口可供访问。

本质就是将局域网部署到服务器上，使局域网可以被任意网络访问。也是服务器这个公网IP穿透内网，是内网得以被其他网络访问（也就是局域网借助服务器成为了公网的一个端口可供所有网络进行访问）。

实现步骤：使用服务器的一个端口，开启一个服务端。局域网的ssh端口或其他进程的端口连接到服务器的一个开放的端口，注意端口不能重复占用。这样就借助服务器的服务端将内网暴露于公网中可供访问。

![1649077572123](Linux基础学习笔记.assets/1649077701052.png)





要使用服务器上访问局域网，（只需要做一个端口转发）局域网使用ssh连接上服务器，再进行端口转发，相当于在服务器上的一个端口分配局域网的IP和ssh端口22即可。





## 13、TCP的状态转换

==netstat  -apn  | grep 端口号    可以查看对应端口的服务器和客户端的状态==

主动连接（客户端）：发起连接，发送SYN包，对方应答并发送SYN包，主动端发送应答建立连接。

被动连接：（服务端）：accept等待连接，接收到连接请求后，发送SYN包和应答，等待对端发送应答进入建立状态。



主动关闭（两端都有可能）：主动发起关闭一端发送FIN包（进入FIN_WAIT_1），接收到应答后进入半关闭状态（FIN_WAIT2），对端如果也想关闭了，那就对方发送应答的同时也发了个FIN包，此时主动发起一方发出应答后会进入TIME_WAIT状态，等待2分钟，因为应答可能丢了（为了确保很好的关闭），如果应答真的丢了，此时被动关闭一端会再发FIN包，主动端也再应答，直到关闭成功。

被动关闭（）：接收到FIN包并应答，进入等待关闭状态（CLOSE_WAIT），此时还能再发送数据，对端处于半关闭状态，再发送FIN包请求关闭（LAST_ACK），等待此次通信的最后一次应答，接收到应答后直接关闭，对端就一直处于FIN_WAIT2等待2MSL时长（如果服务器关闭，就进入了TIME_WAIT状态），怕没收到ACK（仁至义尽，可靠关闭）。



连接特殊情况：在客户端连接到最后由于某些原因没有回应答，客户端的操作系统会发送一个RST信号请求重新发起连接

关闭的特殊情况：当使用dup2将别的输入输出重定向到socket套接字的文件描述符上，此时close只能关闭最开始的文件描述符，其他重定向依旧可以读写套接字，此时需要调用shutdown函数进行全部关闭，shutdown还可以单独关闭读端或者写端。实现了半关闭状态。

![1649130486697](Linux基础学习笔记.assets/1649130486697.png)

- 端口复用，实现端口在服务器关闭时处于TIME_WAIT状态下重新启动不会因为端口占用发现错误。但仍然TIME_WAIT状态仍然保持。

  使用setsocketopt函数（），man page中描述较少，可以参考书目是《UNIX 网络编程》

## 14、多路I/O转接服务器

思想：多路1O转接服务器也叫做多任务1O服务器。该类服务器实现的主旨思想是，不再由应用程序自己监视客户端连接，取而代之由内核替应用程序监视文件。（类似信号通知的方式，像中断，借助内核进行监听与通知）

### 1、select（）

- int select(int nfds, fd_set *readfds, fd_set *writefds,
                    fd_set *exceptfds, struct timeval *timeout);

  最后一个参数穿NULL阻塞等待，传0立即返回，大于0表示等待的时长

![1649133136362](Linux基础学习笔记.assets/1649133136362.png)

- select（）的弊端：

![1649134370009](Linux基础学习笔记.assets/1649134370009.png)

自定义数据结构，数组中存储自己需要监听的文件描述符，当select（）返回返回个数时，只需要遍历自定义的数组中的文件描述符是否在返回的集合（传出参数 ）中即可（配合FD_ISSET()）。

### 2、poll（）

- poll函数实现了将数组的定义（第一个形参就是监听的数组），并把情况封装在对应的结构体中，方便遍历，不用再使用函数进行判断。（当需要监听同一个文件描述符的读写时需要向数组中加入两个结构体）
- nfds是前面数组中需要监听的文件描述符的个数

![1649141764986](Linux基础学习笔记.assets/1649141764986.png)

### 3、epoll（）

内核实现是使用红黑树，调用epoll_creat（）创建出一个树根节点，返回一个句柄，再通过调用epoll_ctl()对树进行插入节点，节点就是需要监听的文件描述符，最重要的参数就是struct  epoll_events，其成员data后续是作为传出参数返回文件描述符，其数据类型时候一个联合体。

![1649145507202](Linux基础学习笔记.assets/1649145507202.png)

通过epoll_wait中的struct epoll_event[]作为传入传出参数进行处理

![1649147629766](Linux基础学习笔记.assets/1649147629766.png)

![1649148105840](Linux基础学习笔记.assets/1649148105840.png)



利用结构体中的data这个联合体中有一个void *ptr，可以让它指向一个结构体，结构体中又有自己的成员，成员中有对应的处理函数，通过fd形参进行判断，就可以封装一个比较万能的函数。而在节点上的data的初值是自己开始赋值的，在插入前已经确定的，所以后续返回什么样的文件描述符就执行对应的参数，典型的回调函数。

![1649148967781](Linux基础学习笔记.assets/1649148967781.png)

边沿触发：epoll ET  只有当监听的文件描述符有数据才会触发，即客户端发数据了才会被触发，节省cpu的使用（此方式可以提高效率，只接收一小部分对数据进行判断是否需要在执行后面的读取，若不需要了就把缓冲区清空即可）

水平触发：epoll LT  只要文件缓冲区中有数据就会一直触发 ，只要有数据就会多次进入epoll_wait

非阻塞I/O：通过设置读缓冲区的方式为非阻塞，通过循环轮询的方式实现边沿触发也能一次将缓冲区读完

![1649293153210](Linux基础学习笔记.assets/1649293153210.png)

==上面几种监听文件描述符的函数可以用于其他 使用文件描述符通信的情况，像管道和文件等==



- epoll反应堆模型：

![1649294198711](Linux基础学习笔记.assets/1649294198711.png)

几个关键点：

1. 封装了创建socket()的过程

2. 加了用于判断状态变量

3. 超时剔除的机制

4. 使用泛型指针指向一个结构体，给此结构体提供初始化方法(eventset()）

5. 回调传参将本结构体自己传进去(因为此结构体也作为状态和数据的存储，回调函数可能需要对数据进行处理和状态的改变)

6. 在初始化结构体时已经指定了回调函数的选择。（连接的回调和接收数据的回调）

   回调函数中的实现是处理的关键，包括查找数组空位，增减就绪的节点和修改监听的状态。

7. tip：监听树上的文件描述符，满足就绪会存到epoll_event events[MAX_EVENTS+1]数组中，提高遍历的效率，同时在处理完后也会从就绪态转为非就绪，同时修改监听其写事件是否满足，以便服务端得到写通知进行写出，防止了阻塞。

   ​

### 4、线程池(用于管理多个线程，派活与销毁 等)

![1649324534692](Linux基础学习笔记.assets/1649324534692.png)

1. 线程池作为就绪任务的消费者，阻塞在就绪任务为空上；生成者为server，阻塞就绪任务队列为满上，就绪任务为共享资源，需要上锁
2. server作为消费者将连接和已就绪文件描述符消费添加到就绪任务中，客户端作为生成者，server阻塞在连接和就绪文件描述符为空上，客户端阻塞在就绪任务存储列表为满上

==代码实现==

上面图的左半边实现：

1. 线程池结构体和任务队列结构体

2. 在创建线程池时初始化结构体和线程数组，开辟任务队列，初始化锁，以启动最小线程数启动线程和管理者线程

3. 在创建线程时进行线程创建并将已经初始化好的线程池结构体作为参数传入，作为线程函数的参数使用

   ![1649334991490](Linux基础学习笔记.assets/1649334991490.png)

4. 线程函数即为回调函数，在回调函数中，进行一些线程池状态判断，如果线程池状态为关闭，那么线程一个释放；后面就是阻塞等待任务到来后的通知后解除阻塞或者已经有任务从任务队列的头取出处理函数和参数然后执行（出队后需要更新任务队列情况）。（本线程在忙之前应该先改变线程池结构体的计数，记得上锁，处理完任务后也得修改线程池结构体的计数并且解锁）。

5. 线程管理器：进行回收算法实现，并发通知使阻塞的线程任务调用pthread_exit()退出。进行开辟线程算法实现，满足将创建一定数量的线程。



终止过多空闲线程的操作，通过设置了需要退出的线程数和发信号唤醒使线程自己pthread_exit(),注意需要提前设置线程分离，不然会残留僵尸线程。

![1649338091305](Linux基础学习笔记.assets/1649338091305.png)





