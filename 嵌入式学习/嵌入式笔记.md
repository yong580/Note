# STM32

## 0、开发模式：

old：vscode结合keil5（vscode编写代码，keil进行调试）

==cube进行芯片和外设和FreeRTOS配置，移植到Platformio中进行功能开发和任务实现。==

## FreeRTOS+PIO+Cube工程配置

### 1、PIO使用

- 下载对应的板级支持包，新建工程选择框架，关键是platformio.ini的配置

  ​

  ​

- platformio.ini配置：

  ```ini
  [env:genericSTM32F103VE]
  platform = ststm32
  board = genericSTM32F103VE
  framework = stm32cube
  debug_tool = cmsis-dap
  upload_protocol = cmsis-dap

  build_flags =
      -Ilib/FreeRTOS/CMSIS_RTOS
      -Ilib/FreeRTOS/include
      -Ilib/FreeRTOS/portable/GCC/ARM_CM3
  ```

  1. platform：厂商
  2. board：芯片型号
  3. framework：框架
  4. debug_tool：调试工具
  5. uploaad_protocol：仿真下载器
  6. build_flags：头文件路径，会自动添加到vscode的配置文件中

  ​

### 2、Cube使用

1. 下载包
2. 新建并配置时钟和外设
3. 生成选项，整个工程的配置。

### 3、FreeRTOS移植

- 普通CMSIS工程移植FreeRTOS步骤
  - 将源码拷贝到工程目录下
  - 关键是头文件的包含和添加（中断实现的.c中需要添加头文件）
  - 配置文件根据需求找模板然后进行配置
  - 还需要将FreeRTOS的接口 重新进行宏定义，还有systick中断的实现，其实就是调用FreeRTOS的vPortSystickHandle函数（参考野火工程）。
- 使用STM32Cube中间件移植FreeRTOS
  - 在进行工程配置时选择FreeRTOS选项即可，一般选择V1即可
  - 在生成工程时会有一个中间件文件夹，同时在Inc会 生成配置文件FreeRTOSConfigure.h，在Src中生成一个freertos.c
  - 移植到platformio只需把cube工程下的src和inc都对应移动到src和include下，把中间文件夹移动到lib下即可。

### 4、三者结合的模板和使用方式

Platformio对STM32Cube支持度很高

1. 首先使用Platformio创建一个STM32cube工程，工程的命名以此处的为主。然后修改Platform.ini文件，添加调试仿真下载工具，添加头文件的路径

2. 只需要将STM32Cube使用makefile方式创建工程，选择的文件夹是第一步中使用platformio工程创建的上一级路径，命名和步骤一保存一致。

3. 创建完成后，只需将中间件的文件夹移动到Core/Src下即可，这是最关键的一步，必须放在Src下（主要是现在自己还不理解这个makefile的实现，最后的链接似乎没有将放在库中的.c生成的.o链接进去，所以目前把库都放在Core/Src中）

4. 就能正常进行开发了，而且每次要修改配置时，只需重新生成即可，只要注意规范，将用户代码放置在用户代码区，生成时就会进行保留

   关键得在模板中的用户区进行代码编写，后续添加配置就不会修改你的用户代码，只会添加配置。由于FreeRTOS的文件夹被移动了，所以重新配置需要自己更改配置文件，硬件则不需要。

5. 注意使用c++的话工程中的freertos.c中的函数声明需要放到一个头文件中，并在main.cpp中进行包含，freertos.c中的用户逻辑代码还是得放到user code 中去，避免更新配置被刷了。





**利用STM32Cube生成配置文件**

附：

STM32Cube下载教程：

https://blog.csdn.net/Brendon_Tan/article/details/107685563

STM32Cube 生态系统之网站、视频、文档及教程汇总

https://blog.csdn.net/Brendon_Tan/article/details/107722164



## 1、bootloader（boot0和boot1）

- 通过使boot0和boot1选择不同的电平，选择以存储在哪的启动程序运行

  | BOOT0 | BOOT1 | 启动模式       | 说明                         |
  | ----- | ----- | -------------- | ---------------------------- |
  | 0     | X     | 用户闪存存储器 | 用户闪存存储器被选为启动区域 |
  | 1     | 0     | 系统存储器     | 系统存储器被选为启动区域     |
  | 1     | 1     | 内嵌SRAM       | SRAM被选为启动区域           |

- 可以选择使用固件自带的bootloader程序，是在芯片生成就烧录在系统存储器中的

  当使用ISP进行程序下载时，就是利用的存储系统中的那段BootLoader 程序

- **也可以选择从用户flash加载BootLoader，用户自己在flash中存储一段BootLoader程序，用于更新固件，（注意需要把APP程序的跳转地址记录在IAP或者说flash中 ）通过使用自己定义的方式下载APP程序。需要注意的是，在跳转到APP程序时，在APP程序中修改终端向量表的位置为APP的地址（即APP程序的起始地址）**

  **下面是在程序开始从复位中断函数运行之前进行的一些初始化，初始化了堆栈指针，因为APP程序中中断向量表的位置在程序起始位置也就是下面的0x8004000，下面JumpToApp是在没有需要进行APP升级的情况下超时判断后执行的，定义了一个函数指针指向了复位中断函数的地址，在程序中调用后就可以跳转到APP中去了**

  ​

  ```c
  void iap_load_app(u32 appxaddr)
  {
      unsigned char i = 0;
  	if(((*(vu32*)appxaddr)&0x2FFE0000)==0x20000000)	//检查栈顶地址是否合法
  	{ 
          /* 首地址是MSP，地址+4是复位中断服务程序地址 */
  		jump2app=(iapfun)*(vu32*)(appxaddr+4);
              
           /* 关闭全局中断 */
          __set_PRIMASK(1); 
  ```


```
      //下面在进行反向初始化 ，后续跳转 到APP程序需要重新初始化，降低IAP和APP的耦合       
      /* 关闭滴答定时器，复位到默认值 */
      SysTick->CTRL = 0;
      SysTick->LOAD = 0;
      SysTick->VAL = 0;
      
      /* 设置所有时钟到默认状态 */
      RCC_DeInit();
      
      /* 关闭所有中断，清除所有中断挂起标志 */  
      for (i = 0; i < 8; i++)
      {
          NVIC->ICER[i]=0xFFFFFFFF;
          NVIC->ICPR[i]=0xFFFFFFFF;
      }
      
      /* 使能全局中断 */ 
      __set_PRIMASK(0);
      
      /* 在RTOS工程，这条语句很重要，设置为特权级模式，使用MSP指针 */
      __set_CONTROL(0);
      
      MSR_MSP(*(vu32*)appxaddr);					//初始化APP堆栈指针(用户代码区的第一个字用于存放栈顶地址)

  		jump2app();									//跳转到APP.后续就是去执行APP里的逻辑，都是用户自己通过Can传输到flash中的
          

      /* 跳转成功的话，不会执行到这里，用户可以在这里添加代码 */
      while (1)
      {

      }

  	}
  }			
```


- 借助上面利用用户自定义的BootLoader进行跳转到APP，也可以实现利用用户自定义的BootLoader跳转到系统存储器中的BootLoader运行，就可以不用更改boot0和boot1就可以使用串口下载。

## 2、使用IAP进行固件更新

- 将IAP程序使用ICP(in circuit program在线编程)或ISP进行烧写进Flash

  ICP：主要有SWD/JTAG协议。

  IAP程序实现：

  1. 通信方式的选择，通信协议，可以分包进行传输与写入，可以实现上位机进行（以太网、wifi网络传输、蓝牙、串口、can）
  2. flash擦写，主要为解锁，擦除页，写入页，上锁
  3. App跳转，实现从IAP程序跳转到App程序，需要重新指定中断向量表（flash的起始位置），并且做好启动程序所做的事情后开始执行。

### 补充下载器接口

- swd完备需要使用5根线，但复位线可以省略，因为swd自带复位协议 。电路图上需要注意的是上下拉（其实也可以不用，因为内部已经上下拉了）。

- JTAG接口需要20个引脚，但在开发板上只需要5个引脚和仿真器连接，可以转为SWD接口,也就是使用SWD的仿真器可以转换为JTAG接口进行仿真下载。

- 下面20脚的接口为JTAG下载接口，使用仿真器上只需要使用SWD接口5根线转换为JTAG接口插入即可。

  所以20脚很多只是板子上进行连接，仿真器的接口线只需要5根（**TMS/SWIO、TCK/SWCLK、GND、VCC、RST**），也可以使用20个口的JTAG仿真器。

  ![1650891169406](嵌入式笔记.assets/1650891169406.png)

  ![1650890613196](嵌入式笔记.assets/1650890613196.png)

  ​

## 3、MDK编译

- 几个段（code、ro-data、rw-data、zi-data）（区分初值为0或者非0是因为静态和动态对数据的要求不一样，静态时如果初值为0，就不需要存在flash浪费空间，在后面用到时再申请存到RAM中）

  程序静态存储时：flash中存着code、ro-data、rw-data

  动态时：flash中存着code、ro-data

- 编译工具链

  ![1646749508778](嵌入式笔记.assets/1646749508778.png)

  使用fromelf.exe可以在链接完成后生成.bin文件

  fromelf.exe --bin --output USART.bin .\USART.axf
  ```

  使用fromelf.exe生成反汇编（-c命令disassemble）

  ```
  fromelf.exe -c --output USART.list .\USART.axf

- 输出的中间文件都在output文件夹下，工程的一些配置会存在project下的.uvprojx文件中

- elf文件包括可重定位文件（.o文件）、可执行文件（不可重定位）、共享目标文件（也是可以重新定位）

  .o文件链接生成可执行文件

- .axf文件里面存的是整个程序的实际存储地址，各种类型的数据存储的位置和占用空间大小

- .htm可以查看静态栈空间的大小，一般分配的栈空间要是其大小的两倍

![1646839806589](嵌入式笔记.assets/1646839806589.png)

- map文件

从map文件可以看出程序链接了什么，用到了多少存储空间（flash和RAM），移除了工程哪些没用到的东西

==tip：关于flash从0x0800000开始的原因，地址映射，将flash映射到0x0（其实可以理解为互相映射），复位后从0x0开始运行没问题，更改向量表位置也没关系，前提是设置好中断向量表的起始地址，映射关系没变，变的是CPU找中断向量表的位置==

![1646873598494](嵌入式笔记.assets/1646873598494.png)

![1646875004291](嵌入式笔记.assets/1646875004291.png)



- 分散加载文件.sct，实现内存自己分配，可以为程序和变量分配空间，后续编译器会自己链接

  指定使用的RAM区和指定某个节区存储在哪个段

  ![1647171084972](嵌入式笔记.assets/1647171084972.png)

  上面指定数组EXtestGrup[1024]分配到EXRAM节区，在.sct文件中可以进行节区存储位置设置

  也可以使用____attribute____at(地址)

  如果使用了外部SRAM的话初始化应该放在__main之前，![1647171539949](嵌入式笔记.assets/1647171539949.png)

  如果在初始化SRAM没有用到局部变量而是采用操作寄存器的方式进行的话就可以把栈空间放在外部SRAM。

  默认优先分配到大一点的空间，关于时钟stm32f103rcc.o最好也是分配在内部SRAM中

- 读写内部flash

  内部flash如果还有剩余空间，可以使用此空间进行掉点的数据保护，下次上电还能读取之前的运行数据

  ![1647173589354](嵌入式笔记.assets/1647173589354.png)

  flash读写结合野火的ppt和STM32F10xxx闪存编程参考手册.pdf进行操作。

  - 读：解锁、写寄存器、读取、上锁

  - 写：解锁、写寄存器、擦除（赋值基地址）、写寄存器（PG位）、写、写寄存器（清楚刚刚对寄存器的操作）、上锁（写入是一次只能写入16位，且为小端对齐）

    在知道flash中怎么存代码，也知道如何对flash进行写入，便可以实现程序对flash进行写入实现APP

  - 读写保护：对代码进行保护，防止泄露

- 在RAM调试

  ![1647184828134](嵌入式笔记.assets/1647184828134.png)

  ​					5记得修改向量表基地址


## 4、电源管理

![1647231412910](嵌入式笔记.assets/1647231412910.png)

- 四种模式：

  - 睡眠：除了内核时钟，片上外设和CM3的外设正常运行
  - 停止：外设正常工作  ，所有外设停止工作，但保留了之前的运行状态，唤醒后可继续执行
  - 待机：程序实现关电源，唤醒后相当于复位

  ![1647231589309](嵌入式笔记.assets/1647231589309.png)

- PVD掉电保护

  选择阈值，需要配置PVD中断，当电压低于阈值后，触发中断，在中断中进行紧急操作。


--------------------

## STM32CubeMX

### 下载对应芯片的库

在help->Manage embedded software packages中下载对应的芯片包

### 新建工程（后续补充）

1. 芯片选型，搜索到使用的芯片

- 在PINOUT&Configuration中选择并进行可视化配置，都是在初始化，想引脚模式和外设初始化等

2. 配置时钟树，会生成对应的初始化函数

3. 配置需要的外设。

4. 在Project Manger中进行项目的配置，比如工程和整个项目的配置，比如编译器、堆栈大小、芯片库等

   还有代码生成器配置，比如添加代码生成模板，是否包含所有库文件等。在Advanced Setting中可以设置使用LL还是HAL库

5. 生成代码即可



# RTOS学习（STM32&PIO&Cube）

## 1、项目搭建

参考野火---《FreeRTOS 内核实现与应用开发实战—基于STM32》第四章

1. 新建工程，选择芯片（启动文件等）

   ![1645259493683](嵌入式笔记.assets/1645259493683.png)

2. 新建文件组，工程目录结构

   ![1645259549652](嵌入式笔记.assets/1645259549652.png)

3. 添加头文件路径，并修改仿真的时钟



## 2、裸机程序

### 1、轮询系统

轮询系统即是在裸机编程的时候，先初始化好相关的硬件，然后让主程序在一个死循环里面不断循环，顺序地做各种事情

![1645259743554](嵌入式笔记.assets/1645259743554.png)

### 2、前后台系统

前后台系统是在轮询系统的基础上加入了中断。外部事件的响应在中断里面完成，事件的处理还是回到轮询系统中完成，中断在这里我们称为前台，main 函数里面的无限循环我们称为后台，==借助中断进行选择执行对应的代码==。但是如果处理时间较短，可以在中断内处理，但是过长的处理需要到后台进行处理。相比轮询系统，前后台系统确保了事件不会丢失，再加上中断具有可嵌套的功能，这可以大大的提高程序的实时响应能力。

**通常在中断子程序中是不调用延时子程序的，这样会增加中断处理时间，如果有其它低级中断了，就会延误响应中断了。所以，中断子程序中不要写调用延时子程序，中断子程序也不要写得过长，处理过多的任务，要尽快处理后及时返回，如果中断一次有很多任务需要执行完全，可以在中断子程序中设置一个标志位，在主程序中查这个标志位，当标志为1时，就在主程序中完成这些任务，这样就不会影响其它中断源的中断，也不会使中断产生混乱。**



![1645243844967](嵌入式笔记.assets/1645243844967.png)





## 3、多任务系统

**相比前后台系统，多任务系统的事件响应也是在中断中完成的，但是事件的处理是在任务中完成的。在多任务系统中，任务跟中断一样，也具有优先级，优先级高的任务会被优先执行。当一个紧急的事件在中断被标记之后，如果事件对应的任务的优先级足够高，就会立马得到响应。相比前后台系统，多任务系统的实时性又被提高了。**

![1645243955579](嵌入式笔记.assets/1645243955579.png)

## 4、裸机系统和多任务系统的对比

![1645244056016](嵌入式笔记.assets/1645244056016.png)

## 5、数据结构列表与列表项的实现（双向链表）

- freeRTOS文件中的list.c和list.h实现
- 主要定义了一个链表结构体和链表项（包括精简节点和普通节点，精简节点用作起始和终止节点和判空用）

## 6、任务的定义与切换

- 任务控制块是每个任务的所有信息，任务栈指针，任务入口，优先级，

- 创建任务

  tcb：任务控制块，将任务控制块挂载在就绪列表中，由系统完成对任务的调度，核心是创建并初始化任务，并添加到就绪列表中。

  （核心函数是vListInsert，将任务控制块的列表项插入就绪列表中）

- 实现就绪列表

  实际就是一个初始化一个有序的数组可以存储任务节点的列表，可以将任务节点插入（vListInsert）

- 实现调度器

  一个是创建了空闲任务（由用户提供创建的函数接口），还有就是开启任务调度。

  tip：定义变量加上volatile时，就是该变量会以编译器无法预知的方式发生变化，请编译器不要做优化（所有的编译器的优化均假设编译器知道变量的变化规律）

- 任务切换

  显示手动调用了taskYIELD()，进行任务切换，实则也是触发PendSV中断，在PendSV中断中进行上下文切换。

- ==任务开始，使用svc软中断进行第一个任务的开始，使用PendSV进行任务切换==

  ![1645863503721](嵌入式笔记.assets/1645863503721.png)

![1645863591089](嵌入式笔记.assets/1645863591089.png)

- 注意点:

  1. 汇编函数中需要堆栈8字节对齐

  2. 寄存器R4-R11不会自动出栈需要手动出栈。

  3. 切换出栈时使用的栈为进程栈

  4. 进入中断需要压栈中断中可能会被改变的寄存器，像上面的r3和r14，在执行函数vTaskSwitchContext函数之前需要对r3和r14进行保护，防止寄存器的值被覆盖，现场被破坏。

  5. r14寄存器是一个伪造好的值，就是一个特殊的返回值，使在返回时使用进程栈PSP作为SP指针出栈。

     ​

## 7、临界段保护

[FreeRTOS 临界段和开关中断 - Crystal_Guang - 博客园 (cnblogs.com)](https://www.cnblogs.com/yangguang-it/p/7161486.html)

- 临界段就是一段在执行的时候不能被中断的代码段。在 FreeRTOS 里面，这个临界段最常出现的就是对全局变量的操作。临界段在系统调度（PendSV）和外部中断时会被打断，所以最后FreeRTOS 对临界段的保护最终还是回到对中断的开和关的控制，控制好中断的开与关实现对临界段的保护，让它能执行完。

- ![1645500849119](嵌入式笔记.assets/1645500849119.png)

  ==分为可嵌套和不可嵌套，可嵌套就是在进入临界段前需要先用变量存在当前中断的开关情况，在退出临界段时传入进行恢复原来的中断开关情况==

  ![1645501055728](嵌入式笔记.assets/1645501055728.png)


## 8、空闲任务

- 在CPU没有被任何其他任务占用时会执行空闲任务，实现一些内存管理和用户钩子函数
- 或者用于使系统进入低功耗

## 9、阻塞延时

- 将任务在延时时不去进行执行，使用系统systick进行中断为其计时，延时到时间再切换回来执行该任务，大大提高了对CPU的性能的利用，在中断中都会进行任务延时时间的检查，然后调用任务切换函数，进行任务块的切换

- 关键是使用两个延时链表，一个用于时钟溢出，一个用于当前计时，当溢出时（系统时钟变为0时）交换链表指针的指向。

- 增加了一个记录下一个最近要解除延时加入到就绪列表的时间的变量xNextTaskUnblockTime，每次时基函数中会依据该变量进行判断是否要解除延时并更新该变量，避免了每次都对延时链表的查看。

- 关于这个全局变量有个重新设置的函数，会重新从延时链表中取出第一项的时间赋值给它，如果延时链表为空，则赋值为最大默认值。

  ```c
  //延时函数，调用时会将任务状态节点挂到延时链表中，并执行任务切换
  vTaskDelay( const TickType_t xTicksToDelay )
  //时基函数
  xTaskIncrementTick()
  //延时函数中执行了xTaskResumeAll()函数置位了pendsvc中断标志位，进行了任务切换
  xAlreadyYielded = xTaskResumeAll();
  ```

- 绝对延时，保证周期一定，不会因为被中断或者其他因素导致周期变化

  ```c
  void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )

  ```

  - 关键点是在判断任务执行时间必须小于整个系统时钟的一个溢出周期
  - 之后就是计算延时的一个时间差，为xTimeToWake - xConstTickCount，弥补了任务被中断的时间，因为xTimeToWake 是根据上次任务唤醒的时间+任务运行的周期得到的，所以保证了时间的绝对性。
  - 需要延时的时间如果溢出是在prvAddCurrentTaskToDelayedList函数处理的，回到之前的相对延时的处理方法

## 9、支持优先级

- 在FreeRTOS中，序号越低，优先级越低，比如空闲任务的优先级是0，最低，

- 在任务块中增加了表示任务优先级变量 uxPriority，记录任务的优先级；

- 增加了一个任务切换时选择最高优先级任务的任务块赋给当前任务块；

- 进而就需要实现找到最高优先级任务的方法，有通用的遍历方法和优化后借助CM3的导零指令获取第一个为1的位置，进而知道最高优先级为多少。，将该任务置为当前任务即可

  ==question==：同一优先级可以挂载多个任务块到就绪列表中吗，应该得实现挂起时移除才能实现这样类似的功能

  ==answer==：这就是时间片的问题，在处理链表的数据结构是已经考虑到这一点，留有一个链表节点索引指针，可以用它遍历同一优先级下链表中的任务，顺序执行，每个tick切换一次。


## 10、任务延时列表实现

- 使用两个列表（考虑了计时变量溢出导致时间戳重新从零开始的问题）对正在延时的任务进行记录，且插入是按需要延时时间的长度进行排序
- 在每次systick中断中的xTaskIncrementTick() 函 数 中判断是否需要切换任务（在该中断中有两种情况需要切换任务，**1**是有高优先级的任务延时结束；**2**是同一优先级有多个任务就绪，需要顺序切换去执行，时间片问题）

## 11、支持时间片

- 本质就是用 listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )这个宏函数实现的在同一优先级级下的链表进行遍历切换任务，也是借助了链表中的一个链表当前索引指针实现对当前任务进行选择，对任务进行切换。

- FreeRTOS的时间片其实就是任务的调度实现任务均可运行，都是等长的一个tick

  tips:在RT-Thread和uC/OS中可以设置时间片的大小，即每个任务运行多少个tick。

==流程==

1. 两种情况触发切换任务：1、任务加入延时列表；2进入systick中断（有高优先级加入就绪列表或者同一优先级下有多个任务在执行）

   ```c
   //延时函数中执行了xTaskResumeAll()函数置位了pendsvc中断标志位，进行了任务切换
   xAlreadyYielded = xTaskResumeAll();

   //在xPortSysTickHandler函数中将Pendsv中断标志位置位
   portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
   ```

   ​

tips：

1. 通过在切换任务条件成立时返回值在systick中进行判断，进而才切换任务（节省不必要的任务原地切换）
2. 就绪列表是一个数组，就绪任务是按优先级存到对应优先级号的链表下 ，延时列表是按延时时间从短到长排序，节点中的xStateListItem成员用于计时，同时插入也是按这个进行链表的排序。
3. 任务切换的过程都是通过汇编实现的，在中断中进行任务切换前应该进行临界段保护，防止被打断。

- 时间片的实现关键的两个函数：

  ```c
  //查找出最高优先级的任务
  portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );
  //实现时间片最重要的函数，每次调用会把链表的索引后移，index表示当前到的任务
  listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );
  //在时基函数中如果有高优先级的任务延时结束或者当前同一优先级链表上存在多个任务，就将切换任务的标志位xSwitchRequired置位pdTRUE。
  ```

### 12、FreeRTOS低功耗

参考文章：[FreeRTOS 低功耗之 tickless 模式 ](https://www.cnblogs.com/yangguang-it/p/7232448.html)

对于 Cortex-M3 和 M4 内核来说，FreeRTOS 已经提供了 tickless 低功耗代码的实现，通过调用指
令 WFI 实现睡眠模式，具体代码的实现就在 port.c 文件中，用户只需在 FreeRTOSConfig.h 文件中配置
宏定义 configUSE_TICKLESS_IDLE 为 1 即可。 如果配置此参数为 2，那么用户可以自定义 tickless 低功
耗模式的实现。 当用户将宏定义 configUSE_TICKLESS_IDLE 配置为 1 且系统运行满足以下两个条件时

- 当前空闲任务正在运行，所有其它的任务处在挂起状态或者阻塞状态。

- 根据用户配置 configEXPECTED_IDLE_TIME_BEFORE_SLEEP 的大小，只有当系统可运行于低功耗模

  式的时钟节拍数大于等于这个参数时，系统才可以进入到低功耗模式。 此参数默认已经在 FreeRTOS.h
  文件进行定义了，下面是具体的定义内容，当然，用户也可以在 FreeRTOSConfig.h 文件中重新定义：

  ```c
  //默认定义的大小是 2 个系统时钟节拍，且用户自定义的话，不可以小于 2 个系统时钟节拍。
  #ifndef configEXPECTED_IDLE_TIME_BEFORE_SLEEP
  #define configEXPECTED_IDLE_TIME_BEFORE_SLEEP 2
  #endif
  #if configEXPECTED_IDLE_TIME_BEFORE_SLEEP < 2
  #error configEXPECTED IDLE TIME BEFORE SLEEP must not be less than 2
  #endif
  ```

函数 portSUPPRESS_TICKS_AND_SLEEP 是 FreeRTOS 实现 tickles 模式的关键，此函数被空闲任务
调用，其定义是在 portmacro.h 文件中：

-------

对 Cortex-M3 和 M4 内核来说，FreeRTOS 自带的低功耗模式是通过指令 WFI 让系统进入睡眠模式，如果想让系统进入停机模式，又该怎么修改呢？FreeRTOS 为我们提供了两个函数：

configPRE_SLEEP_PROCESSING( xExpectedIdleTime )

configPOST_SLEEP_PROCESSING( xExpectedIdleTime )
这两个函数的定义是在 FreeRTOS.h 文件中定义的，什么都没有执行。

## FreeRTOS移植

1. 首先是新建固件库项目
2. 下载源码，在项目中新建存放FreeRTOS文件的项目文件，将源码中的source文件夹下的.c文件复制到FreeRTOS/src中，将include文件和RVDS中对应的芯片文件夹添加到头文件路径中，最后在例程demo文件夹下找到对应的例程复制配置文件FreeRTOSConfig.h到user文件夹下。
3. 在配置文件中修改配置，设置对应的宏即可（开关某个功能，设置一些实现方法和堆栈大小和优先级等）
4. 并在systick中断函数写上对void xPortSysTickHandler( void )函数的调用 ，记得加上需要的头文件，与配置和任务相关的==#include "FreeRTOS.h"//FreeRTOS使用#include "task.h"==


### 




## FreeRTOS应用

### 1、静态创建任务

定义好任务创建需要的变量和实现相应的函数：

1. 堆栈变量

2. 任务控制块

3. 空闲任务堆栈、定时器任务堆栈(用户自定义栈和控制块)

   ![1645950284587](嵌入式笔记.assets/1645950284587.png)

   ​

4. 实现静态内存分配的函数（只是简单的赋值）

   ![1645950083957](嵌入式笔记.assets/1645950083957.png)

   ![1645950341618](嵌入式笔记.assets/1645950341618.png)

5. 在创建任务的任务体中实现对其他任务的调度，调度完后将该任务删除，**在进行其他任务创建时需要进行临界段保护**（防止被打断）

### 2、动态任务创建

- 不用自己分配内存比较简单，但需要改配置文件为动态内存分配

- 同静态一样**需要先创建任务句柄**，用于存创建成功后返回的任务控制块（几个任务几个句柄）

- 配置完后，只需要调用下面创建函数进行任务创建，也不用配置那些定时器任务的信息等

- ```
  - BaseType_t xTaskCreate(TaskFunction_t pxTaskCode,
    							const char * const pcName,
    							const uint16_t usStackDepth,
    							void * const pvParameters,
    							UBaseType_t uxPriority,
    							TaskHandle_t * const pxCreatedTask )
  ```

### 3、FreeRTOS启动流程

- 大致有两种启动流程：一是将所有任务都创建好后，启动调度器进行调度；二是创建一个AppTaskCreate任务并马上开启调度器，在该任务中进行后续所有任务的创建，最后创建完后将AppTaskCreate任务删除。

- **一般用第二种比较稳健，因为一创建完AppTaskCreate就开启调度器进行任务调度，再在AppTaskCreate任务中一步一步将任务创建完毕，直到AppTaskCreate任务执行到最后再把自己给删除了**。

  ![1645974171317](嵌入式笔记.assets/1645974171317.png)

- ==**流程**：上电->复位，初始化MSP->PC指针下一时刻指向Reset_Handler入口，调用Reset_Handler->调用____main初始化系统的堆和栈，最后调用 C 中 的 main 函数，进行硬件初始化，FreeRTOS系统初始化（初始化化堆栈，定义一些静态变量等），创建任务按上面流程，每创建任务如果是动态创建会进行动态内存分配==

### 4、任务管理

- 任务的状态由就绪、阻塞、挂起、结束

- 主要操作是添加到某个列表，从某个列表中删除，理解什么时候状态进行切换，切换的时候需要做什么

  掌握操作任务的函数（tasks.c）。

- 阻塞延时和绝对延时：阻塞延时就是任务运行没有周期，绝对延时就是一个任务在多少时间内必须运行一次，有一个运行周期vTaskIncreasement，只需要设定好上一次唤醒的时间（在运行前获取系统运行时间即可）和任务运行的周期即可，实现非常精准的计时

- 中断：在FreeRTOS中有一套中断中调用的API，中断必须要注意上下文环境，不能进行挂起当前任务的操作，不允许调用会阻塞的API函数接口

  ==一般中断函数都是快进快出，进行一些标志位的改变，进而影响任务主体的运行，在中断中使用主栈指针MSP，在任务中使用任务栈指针PSP；而且必须注意中断的频率==

- 任务中不允许出现没有阻塞机制的死循环，因为出现了之后，优先级低于该任务的任务将永远无法运行

- 空闲任务中可以使用钩子函数，在空闲任务中插入一个函数，但注意不能调用带阻塞/死循环和将空闲任务挂起的API，因为空闲任务有其他功能需要运行，空闲任务是唯一一个不能进行阻塞的任务，因为系统一直都要在运行。

- 任务运行的时间处理：考虑任务周期和任务运行时间（当然任务周期一般也会远远大于运行时间）的关系，运行时间短，周期长的任务一般优先级可以设置得高一点（因为有个任务1运行时间>任务2任务周期，这样的打断会导致任务2周期错乱），当然，越重要的任务优先级理应设置得更高。

- 任务删除：首先是会将任务状态删除，并重新设置优先级，重置下一个唤醒的阻塞时间，如果删除的任务是在正在运行的任务时，先将任务保存在待删除链表中，在空闲任务中再根据uxDeletedTasksWaitingCleanUp变量值进行任务内存空间的释放（调用vPortFree( pxTCB->pxStack )和vPortFree( pxTCB )），如果删除的不是当前任务，就在此函数中直接释放了

==TIP==：最关键的就是掌握对任务操作的API，和任务切换的的机制

### 5、消息队列

#### 1、消息队列的基本理解和使用

- 用来通讯，实现任务间的数据通讯

- 队列： 
  - 数据采用引用传递，需要等待消息被处理后才能将其改变 ，以为是同个东西，优点是节省空间
  - 采用数据拷贝的话不会因为发送方将存储的数据改变而改变，但是占用空间，浪费时间，但其实FreeRTOS也可以使用指针传递，只要将数据的地址作为消息传递即可

- 出队阻塞：
  - 一种是看一眼有没有数据；
  - 一种是阻塞等待一段时间，还是没有数据报出信息然后去执行下面的代码；
  - 一种是一直等到有数据

- 出队阻塞：与入队阻塞类似，变成看数据有没有满而已

- 创建队列（队列创建函数）：队列结构体，位置和存储空间（分为静态创建和动态创建）

- 入队操作（入队函数）：三个参数为 队列句柄，数据地址，阻塞时间  

  如果在中断中数据入队后有任务解锁了，需要在出中断前进行一次任务切换，因为有任务在读消息阻塞，可能获取到数据且优先级更高。紧急的消息 从队首写入

- 出队操作（出队函数）：从指定队列中读取数据到任务定义的缓冲区，如果在阻塞读取消息的任务读取到消息进入就绪态，其优先级可能高于当前任务，读取成功后需要进行一次任务切换，如果是在中断中读取，需要在读取到后出中断前进行一次任务切换

tip：入队出队其实就是数据的两次拷贝，数据拷贝也好地址拷贝也好，当数据量大的时候可以使用指针进行数据传递。

- 删除队列：将消息队列的句柄传入即可将消息队列删除

  ==**个人理解与体会：**发送信号一般和接收信号是双向的，如果发送信号后发不进去（满了），设置了阻塞，就会将该消息加载到发送消息阻塞列表中，等待该队列实现了出队（在消息出队的函数中会进行查看等待的队列是否为空，不为空会通知其可以接触阻塞状态将数据发送进来）后通知 它可以将数据存进队列（当然设置了阻塞时间，一旦超出阻塞时间还没人通知，便会以阻塞溢出返回掉这个发送函数）==

- 消息队列的使用方法较为简单，只需掌握创建、发送、接受的函数应用即可（在理解了内部机制的情况下，如上面的高亮字所说）

#### 2、信号量

- 信号量的主要目的有两个：一个是共享资源的同步，另一个是任务的同步


- 二值信号量
  - 用于任务与任务之间的同步，我有动作后通知你动作
  - 中断与任务之间的同步（以前都是在中断中改变标志位，后续运行到对应任务的地方进行标志位的判断决定是否要执行，采用信号量的优点在于其有阻塞机制，有信号量阻塞等待列表，等待不到信号量是不会执行，以后信号量可以很快执行，不用轮询）
- 计数信号量
  - 用于事件计数和资源管理，用于统计还有多少个事件未处理
  - 运作的机制类似抢车位，运行所有任务对资源进行访问，资源都被占了后还有任务要获取会进入阻塞
- 创建信号量
  - 创建二值信号量（创建后得先进行一次信号释放）
  - 创建计数信号量（有多个信号资源可占用）
  - 创建互斥信号量（只允许一个任务占用，且不可以被打断，拥有优先级继承机制，在高优先级想获取一个低优先级任务正在占领的互斥信号时，高优先级会提高低优先级任务的优先级和自己一样高，防止自己进入阻塞后被中优先级的乘虚而入）
  - 创建递归互斥信号量（允许占有该信号的任务在任务中多次获取改信号，u.uxRecursiveCallCount用于计数获取了多少次，获取几次最后就得释放几次）


==tip：uxMessagesWaiting：用于表示现在队列中消息和信号量的个数，可供获取     uxLength：用于记录允许的存储长度，可以存几个信号量==

​	**关键是创建信号量，信号量的获取与释放**

### 6、事件

- 创建事件，只需创建一个事件句柄。

- 设置事件位（在设置完后会判断是否有等待该标志的时间在事件等待列表中，有就换到就绪中，并且函数最后设置成功会返回设置的位，可以通过与要设置的位进行按位与运算判断是否真的设置了该事件）

- 获取（等待）感兴趣的事件位（会从事件中判断需要获取的标志位是否置1，最后需要根据返回值与感兴趣的为进行按位与运算判断是否真的发生，获取到后可以选择是否清除）

- 使用流程：创建事件-》设置时间位（一般使用宏定义给设置对应位的数字起个有意义的名字）-》需要使用到该事件的任务在任务中获取该事件的对应位（宏定义）

  tip：在中断中设置事件位是通过软件定时器去调用对应的回调函数进行设置的，清除事件位也是一样的。




### 7、软件定时器

- 使用时需要将宏打开，使用软件定时器的方法和其他内核资源类似，但是它是可裁剪的。
- 使用方法：定义软件定时器句柄-》创建软件定时器（设定好重复与否和定时周期）-》启动软件定时器任务（启动后执行软件定时器任务，1获取下一个到期的定时器时间，2判断溢出切换列表，3读取定时器命令队列，处理相应命令，包括所有的处理，包括回调函数的调用）



### 8、任务通知

- 任务通知是隶属于任务控制块的，所以是只能由单个任务来接受信息，且信息没有发送阻塞

- 是一种更加简洁的通信机制，同时速度也更快，更节约资源，在一般情况可以替代事件和信号量

- 使用的函数：

  ![1646485995699](嵌入式笔记.assets/1646485995699.png)

- 使用任务通知可以代替消息（但一次只能传4字节的消息）、二值信号量（无法代替互斥信号量，因为有优先级继承）、计数信号量、事件组。使用方法比IPC（消息队列、信号量、事件）方便且快捷。

### 9、内存管理

- **堆区初始化**

  在创建第一个任务是会进行堆区初始化化，根据用户在配置文件中定义的大小进行初始化

  调用的是`static void prvHeapInit(void)`

  - 该函数的主要操作是进行堆区的8字节对齐

  - 使用一个双向链表进行堆区的分块维护，链表类型为

    ```c
    typedef struct A_BLOCK_LINK
    {
    	struct A_BLOCK_LINK *pxNextFreeBlock; /*<< The next free block in the list. */
    	size_t xBlockSize;					  /*<< The size of the free block. */
    } BlockLink_t;
    //链表头和尾
    static BlockLink_t xStart, *pxEnd = NULL;
    //第一个初始化后存着堆区地址的链表，该链表就是用来存链表的首地址的，也是start中的next指向的值
    BlockLink_t *pxFirstFreeBlock;

    /*下面这段代码是进行8字节对齐 */
    uxAddress = (size_t)ucHeap;
    if ((uxAddress & portBYTE_ALIGNMENT_MASK) != 0)
    {
        //对齐操作，+7是进位，把后三位与成0
        uxAddress += (portBYTE_ALIGNMENT - 1);
        uxAddress &= ~((size_t)portBYTE_ALIGNMENT_MASK);
        //原本大小减去地址对齐损失的大小，得到了当前可以使用的堆区的大小
        xTotalHeapSize -= uxAddress - (size_t)ucHeap;
    }
    //完成对齐的堆区
    pucAlignedHeap = (uint8_t *)uxAddress;

    //如下，pxFirstFreeBlock存着处理过8字节对齐的堆区地址。
    pxFirstFreeBlock = (void *)pucAlignedHeap;
    pxFirstFreeBlock->xBlockSize = uxAddress - (size_t)pxFirstFreeBlock;

    //腾出了一个BlockLink_t结构体的空间用于记录该空闲块的是被使用的还是空闲的，这一点很关键，用于判断此块内存是否空闲，很明显后面用于消除内存碎片化
    uxAddress = ((size_t)pucAlignedHeap) + xTotalHeapSize;

    //初始化堆区曾剩余的最小空间和剩余的可用空间
    xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;

    //后续使用此变量去判断该内存块是否是空闲的
    xBlockAllocatedBit = ((size_t)1) << ((sizeof(size_t) * heapBITS_PER_BYTE) - 1);
    ```

  - 初始化后链表是这个指向是Start-》pxFirstFreeBlock-》pxEnd

- **分配内存函数**`void *pvPortMalloc(size_t xWantedSize)`

  - 第一次创建任务就会涉及到内存分配，会调用这个函数进行内存分配，如果是第一次调用pvPortMalloc，会进行堆区初始化，就是调用上面`prvHeapInit`函数

  - 初始化好后，就有了可分配的内存区域，判断需要的空间和可分配空间的关系，太大就分配失败，返回NULL如果小于就进行分配（当然还可以设置最小的分配空间，xBlockAllocatedBit这个变量设置）

  - 分配给用户的会补上结构体的大小。

    ```c
    xWantedSize += xHeapStructSize;
    ```

  - 分给用户的堆区首地址是去掉开头结构体的

    ```c
    //加上xHeapStructSize跳过了结构体
    pvReturn = (void *)(((uint8_t *)pxPreviousBlock->pxNextFreeBlock) + xHeapStructSize);
    ```

  - 分配后如果该空闲块大于需求的不是恰好的，多出来的需要分割一个小的空闲节点出来插入到空闲堆栈链表中。在将空闲块插入时都是使用的刚刚好的地址头，除去需求的空间后的地址作为空闲堆节点，关键点是xWantedSize在一开始已经补上了一个结构体的大小，所以在分割空闲块时，就是原本节点加上xWantedSize即为分割出来的空闲块的地址，大小即是原本空闲块减去xWantedSize。而在使用空闲块进行内存分配时，会多考虑开始的结构体

    ```c
    //分割完后，将空闲的节点插入空闲堆链表pxFirstFreeBlock
    prvInsertBlockIntoFreeList(pxNewBlockLink);
    ```

  - 完全分配完后，更新**当前的空闲空间大小变量**和**历史最小的空闲空间大小变量**

- ==处理碎片化的方法是，连续就合并并且更新块大小，不连续就分块，关键在`prvInsertBlockIntoFreeList`这个函数中怎么插入，**判断是否连续**是最关键的地方，前连续和后连续==

## 直播课程

裸机，使用状态机进行程序拆分

![1646533435621](嵌入式笔记.assets/1646533435621.png)

![1646534038321](嵌入式笔记.assets/1646534038321.png)

![1646536223193](嵌入式笔记.assets/1646536223193.png)

程序的实质就是指令（flash和CPU）与数据（RAM）

![1646537818527](嵌入式笔记.assets/1646537818527.png)



- 入栈出栈顺序原因：一部分是硬件原因，另一部分是汇编指令原因

![1646560764012](嵌入式笔记.assets/1646560764012.png)





![1646538568144](嵌入式笔记.assets/1646538568144.png)

[(49条消息) ARM的规则ATPCS和AAPCS_猿猿_yzg的博客-CSDN博客_aapcs规则](https://blog.csdn.net/weixin_42135997/article/details/80575937)





产生中断会保存所有寄存器，有些是硬件保存，有些是程序保证保存，比如在切换任务时手动保存的r4-r11。（保护现场相当于保存所有寄存器）

会保存中断地址，方便返回到产生中断的地方，返回地址和函数入口地址（压在lr中）是两码事





RTOS本质：

1. 任务切换（旧任务现场保护，新任务的恢复）

2. 休眠和唤醒，根据状态决定是否运行（延时阻塞、等待消息通知等）

3. 实时，中断>任务

   ​	   任务之间也有优先级，同级时间片轮转

-----------------------------------



# HAL库学习

初始化的结构体定义于头文件中，可选的参数也定义在头文件中

函数实现定义在.c文件中

## 1、GPIO

- 开时钟,均定义为宏函数

  ```
  __HAL_RCC_GPIOB_CLK_ENABLE()
  ```

- 端口的宏和引脚和固件库一致

- GPIO的各种API,可以在stm32f1xx_hal_gpio.h文件中查找，下面列举常用的

  ```c
  //仍然是配置好结构体后进行初始化
  HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
  HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
      
  //对引脚的操作
  GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin);
  void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState);
  void HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin);
  HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin);
  ```


  //中断相关API
  //HAL_GPIO_EXTI_IRQHandler是GPIO中断处理函数模板，只要在真正的中断函数中，也就是中断向量表中的中断函数调用此函数，实现的功能写在该函数中即可，或者以它为模板去写在真正的中断函数中。
  void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin);
  void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin);
  ```

  ```c
  //用于获取中断标志位
  __HAL_GPIO_EXTI_GET_IT ()
  //用于清除中断标志位
  __HAL_GPIO_EXTI_CLEAR_IT()
      
  //在配置好GPIO后，只要使用下面函数即可完成中断配置
  /* 配置 EXTI 中断源 到 key1 引脚、配置中断优先级 */
  HAL_NVIC_SetPriority(KEY1_INT_EXTI_IRQ, 0, 0);
  /* 使能中断 */
  HAL_NVIC_EnableIRQ(KEY1_INT_EXTI_IRQ);
  //在引脚模式配置可以选择什么边沿触发
  GPIO_InitStructure.Mode = GPIO_MODE_IT_RISING;
  ```

  ​

## 补充知识void SystemInit (void)

这个函数是用来初始化系统的 flash和锁相环和系统时钟

当需要重新设置向量表位置时需要将存储地址定义为`USER_VECT_TAB_ADDRESS`这个宏，最终系统初始化调用SystemInit函数就会进行向量表位置初始化，执行`SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET;`

## 2、RCC时钟

- 时钟树

  HES、HSI、锁相环、SYSCLK、AHB、AHB Prescaler、HCLK、APB1(HCLK1 )、APB1 Prescaler、APB2 Prescaler、APB2(HCLK2)

- USB时钟：通过锁相环后的时钟经过分频得到

- Cortex系统时钟：通过HCLK分频得到，1或8分频，这个时钟频率也就是Systick的时钟频率

  [stm32之Cortex系统定时器（SysTick）](https://www.cnblogs.com/CodeWorkerLiMing/p/10362052.html)

- ADC时钟：最高是14M，取自PCLK2的分频，如果APB2高速时钟分频后为72M，那么ADC时钟最快为12M（6分频，因为不能超过14M）

- RTC 时钟（实时时钟模块）：RTC 时钟可由 HSE/128 分频得到，也可由低速外部时钟信号 LSE 提供，频率为 32.768KHZ ；

- 独立看门狗时钟 ：独立看门狗的时钟由 LSI 提供，且只能是由 LSI 提供， LSI 是低速的内部时钟信
  号，频率为 30~60KHZ 直接不等，一般取 40KHZ。 

- MCO 时钟输出 

  MCO 是 microcontroller clock output 的缩写，是微控制器时钟输出引脚，在 STM32 F1 系列中由
  PA8 复用所得，主要作用是可以对外提供时钟，相当于一个有源晶振。 MCO 的时钟来源可以是：
  PLLCLK/2、 HSI、 HSE、 SYSCLK，具体选哪个由时钟配置寄存器 CFGR 的位 26-24： MCO[2:0] 决
  定。除了对外提供时钟这个作用之外，我们还可以通过示波器监控 MCO 引脚的时钟输出来验证
  我们的系统时钟配置是否正确。 

  ```c
  //使用HAL库中的这个函数可以设置MCO引脚使用的时钟，传什么参数具体再看
  HAL_RCC_MCOConf() 
  ```


## 3、systick

- 系统定时器是一个 24bit的向下递减的计数器，计数器每计数一次的时间为 1/SYSCLK，一般我们设置系统时钟 SYSCLK等于 72M，也可以配置成8M。

- 使用的寄存器 

  | 寄存器名称 | 寄存器描述               |
  | ---------- | ------------------------ |
  | CTRL       | SysTick 控制及状态寄存器 |
  | LOAD       | SysTick 重装载数值寄存器 |
  | VAL        | SysTick 当前数值寄存器   |
  | CALIB      | SysTick 校准数值寄存器   |

- ```c
  //库函数用来初始化systick中断的，形参因为两次中断的计数值，主要配置了 SysTick 中的三个寄存器： LOAD、 VAL 和 CTRL和中断优先级
  SysTick_Config()
  ```

## 4、通信

### 自定义通信协议

- 常见的通信协议包含的东西

  ![1652404195356](assets/1652404195356.png)

  通信协议比较简单时可以直接实现几个函数，把每一帧数据中的成员作为参数。或者实现几种常用的调用方式。

  通信协议比较复杂最好还是封装成结构体或者类，封装成类可以方便实现模块化和方便接口管理。

- 一个比较好的方法是使用状态机进行实现，枚举类型。

### 1、串口通信

- USART 支持 DMA 传输，可以实现高速数据传输。

- 波特率的常用值有 2400、 9600、 19200、 115200。 

- 为利用 USART 实现开发板与电脑通信，需要用到一个 USB 转 USART 的 IC 。（比如CH340G芯片 ）

- 校验位：奇校验，所有1个数为奇数，不是奇数奇偶校验位补1

  ​		偶检验同理。

- 发送数据

  - 当发送使能位 TE 置 1 之后，发送器开始会先发送一个空闲帧 (一个数据帧长度的高电平)，接下

    来就可以往 USART_DR 寄存器写入要发送的数据。在写入最后一个数据后，需要等待 USART 状
    态寄存器 (USART_SR) 的 TC 位为 1，表示数据传输完成，如果 USART_CR1 寄存器的 TCIE 位置
    1，将产生中断。 

  - DMA传输：

  - 在发送数据时，编程的时候有几个比较重要的标志位

  | 名称 | 描述                                   |
  | ---- | -------------------------------------- |
  | TE   | 发送使能                               |
  | TXE  | 发送寄存器为空，发送单个字节的时候使用 |
  | TC   | 发送完成，发送多个字节数据的时候使用   |
  | TXIE | 发送完成中断使能                       |

- 接收数据

  - 如果将 USART_CR1 寄存器的 RE 位置 1，使能 USART 接收，使得接收器在 RX 线开始搜索

    起始位。在确定到起始位后就根据 RX 线电平状态把数据存放在接收移位寄存器内。接收完成
    后就把接收移位寄存器数据移到 RDR 内，并把 USART_SR 寄存器的 RXNE 位置 1，同时如果
    USART_CR2 寄存器的 RXNEIE 置 1 的话可以产生中断。 

  - DMA传输：

  - 在接收数据时，编程的时候有几个比较重要的标志位 

    | 名称   | 描述             |
    | ------ | ---------------- |
    | RE     | 接收使能         |
    | RXNE   | 读数据寄存器非空 |
    | RXNEIE | 发送完成中断使能 |

- USART中断请求事件

  | 发送数据寄存器为空                       | TXE       | TXEIE  |
  | ---------------------------------------- | --------- | ------ |
  | CTS 标志                                 | CTS       | CTSIE  |
  | 发送完成                                 | TC        | TCIE   |
  | 准备好读取接收到的数据                   | RXNE      | RXNEIE |
  | 检测到上溢错误                           | ORE       | RXNEIE |
  | 检测到空闲线路                           | IDLE      | IDLEIE |
  | 奇偶校验错误                             | PE        | PEIE   |
  | 断路标志                                 | LBD       | LBDIE  |
  | 多缓冲通信中的噪声标志、上溢错误和帧错误 | NF/ORE/FE | EIE    |

- 程序配置

  - 结构体由cube自动生成，可以自己修改结构体中的参数

  - 使能中断

    ```c
    __HAL_UART_ENABLE_IT(&huart1, UART_IT_RXNE);
    ```

  - 配置和使能硬件相关

    ```c
    //用户自己实现会把库这个函数的若定义覆盖，这个函数会被串口初始化函数调用
    void HAL_UART_MspInit(UART_HandleTypeDef *uartHandle)
    //记得在这个初始化函数中添加开启中断的函数
    HAL_NVIC_SetPriority(DEBUG_USART_IRQ ,0,1);
    HAL_NVIC_EnableIRQ(DEBUG_USART_IRQ ); /* 使能 USART1 中断通道 */
    ```

  - 中断处理函数实现

    ```c
    //中断函数中判断是否真的产生中断，并获取寄存器中的数据，读寄存器时硬件自动将标志位清除，不需要自己手动清除
    void USART1_IRQHandler(void)
        
    ```

  - 最关键的实现能使用printf和scanf函数，进行函数重定向

    ```c
    //重定向c库函数printf到串口DEBUG_USART，重定向后可使用printf函数
    #if defined(__GNUC__)
    int _write(int fd, char *ptr, int len)
    {
      HAL_UART_Transmit(&huart1, (uint8_t *)ptr, len, 0xFFFF);
      return len;
    }
    #elif defined(__ICCARM__)
    size_t __write(int handle, const unsigned char *buffer, size_t size)
    {
      HAL_UART_Transmit(&huart1, (uint8_t *)buffer, size, HAL_MAX_DELAY);
      return size;
    }
    #elif defined(__CC_ARM)
    int fputc(int ch, FILE *f)
    {
      HAL_UART_Transmit(&huart1, (uint8_t *)&ch, 1, HAL_MAX_DELAY);
      return ch;
    }
    #endif
    ```

## 5、DMA（Direct Memory Access 直接存储器存取 ）

- 用来搬数据，但是不需要占用 CPU 

- 数据传输支持从外设到存储器或者存储器到存储器 ，存储器可以是 SRAM 或者是 FLASH 

- 外设要想通过 DMA 来传输数据，必须先给 DMA 控制器发送 DMA 请求， DMA 收到请求信号之后，控制器会给外设一个应答信号，当外设应答后且 DMA 控制器收到应答信号之后，就会
  启动 DMA 的传输，直到传输完毕。 

- 使用 DMA，最核心就是配置要传输的数据，包括数据从哪里来，要到哪里去，传输的数据的单
  位是什么，要传多少数据，是一次传输还是循环传输 

- DMA 传输数据的方向有三个：从外设到存储器，从存储器到外设，从存储器到存储器。
  具体的方向 DMA_CCR 位 4 DIR 配置： 0 表示从外设到存储器， 1 表示从存储器到外设。

  这里面涉及到的外设地址由 DMA_CPAR 配置，存储器地址由 DMA_CMAR 配置。 

## 6、ADC

- 配置GPIO，模式选择模拟输入

- 配置ADC

  - GPIO

  - 结构体

    ```c
    ADC_HandleTypeDef ADC_Handle;
    //每个通道的配置结构体，配置通道的采样排序和采样周期长度
    ADC_ChannelConfTypeDef ADC_Config;
    HAL_ADC_ConfigChannel(&ADC_Handle, &ADC_Config);
    ```

  ​

- 如果使用中断，记得使能中断，并可以使用回调函数进行数据处理

  - 使能ADC中断

    ```c
    //设置中断
    HAL_NVIC_SetPriority(Rheostat_ADC_IRQ, 0, 0);
    HAL_NVIC_EnableIRQ(Rheostat_ADC_IRQ);
    //开启中断
    HAL_ADC_Start_IT(&ADC_Handle);
    ```

    ​

- 使用DMA的话得先配置DMA

  - 结构体

    ```c
    DMA_HandleTypeDef hdma_adcx
    //初始化后进行连接
    HAL_DMA_Init(&hdma_adcx); 
    //连接
    __HAL_LINKDMA( &ADC_Handle,DMA_Handle,hdma_adcx);
    //启动DMA
    HAL_ADC_Start_DMA(&ADC_Handle, (uint32_t*)&ADC_ConvertedValue, 1);
    ```

- 多路ADC采集

  - 配置方式和上面一路是一样的

  - 但是每个通道都得调用一次通道初始化函数

    ```c
    HAL_ADC_ConfigChannel(&ADC_Handle, &ADC_Config);
    ```

## 7、定时器

### 1、基本定时器

- 时基结构体，设置好重装载值和分配系数和计数方向即可

  ```c
  typedef struct {
  uint32_t Prescaler; // 预分频器,定时器计数频率CK_CNT=TIMxCLK/(PSC+1)
  uint32_t CounterMode; // 计数模式，计数方向
  uint32_t Period; // 定时器周期，一次溢出或者重装载的计数次数，ARR寄存器，重装载值，计算时需要+1
  uint32_t ClockDivision; // 时钟分频
  uint32_t RepetitionCounter; // 重复计算器
  } TIM_TimeBaseInitTypeDef;
  ```

- TIM_MasterConfigTypeDef结构体目前不知道什么用，跟着配置先

- **最重要的是中断的配置，打开什么类型的中断必须放在最后。**

  ```c
  //中断源优先级设置，并打开此中断源
  HAL_NVIC_SetPriority(TIM6_IRQn, 5 , 0);
  HAL_NVIC_EnableIRQ(TIM6_IRQn);
  //打开该源的什么中断，这个必须在所有有关定时器都配置完后才能打开，才有效，不然定时器不工作
  HAL_TIM_Base_Start_IT(&htim6);
  ```






# 嵌入式系统

## 1、概述

![1644322521228](嵌入式笔记.assets/1644322521228.png)

### 1、嵌入式系统的定义

![1644321928517](嵌入式笔记.assets/1644321928517.png)

![1644322077483](嵌入式笔记.assets/1644322077483.png)

![1644322157236](嵌入式笔记.assets/1644322157236.png)

![1644322218132](嵌入式笔记.assets/1644322218132.png)

![1644451036917](嵌入式笔记.assets/1644451036917.png)

![1644451183282](嵌入式笔记.assets/1644451183282.png)

![1644451619223](嵌入式笔记.assets/1644451619223.png)

学习的方法：博、专、实践。

---

## 2、嵌入式操作系统

### 1、特点

![1644452244785](嵌入式笔记.assets/1644452244785.png)

### 2、RTOS

![1644452602567](嵌入式笔记.assets/1644452602567.png)

### 3、uc/OS-II

![1644452935729](嵌入式笔记.assets/1644452935729.png)

### 4、FreeRTOS

![1644453230604](嵌入式笔记.assets/1644453230604.png)

###5、嵌入式Linux

![1644453170259](嵌入式笔记.assets/1644453170259.png)



- linux层次结构（一切皆文件）

![1644454251824](嵌入式笔记.assets/1644454251824.png)

![1644454338461](嵌入式笔记.assets/1644454338461.png)



## 3、ARM处理器构架

![1644932872331](嵌入式笔记.assets/1644932872331.png)



###1、预备知识

![1644472425904](嵌入式笔记.assets/1644472425904.png)

![1644472449591](嵌入式笔记.assets/1644472449591.png)

- CPU的一些知识

  ==一般较好的处理器现在都有DMA总线，直接数据访问，从存储器直接传输到外设不经过CPU==

  CPU所能访问的数据称为地址空间。

![1644480356679](嵌入式笔记.assets/1644480356679.png)

![1644480661548](嵌入式笔记.assets/1644480661548.png)

![1644481377851](嵌入式笔记.assets/1644481377851.png)

![1644481490585](嵌入式笔记.assets/1644481490585.png)

###2、ARM处理器概述

####1、由来

![1644482068128](嵌入式笔记.assets/1644482068128.png)

####2、产品系列

![1644482105808](嵌入式笔记.assets/1644482105808.png)

####3、精简指令集和片上系统概念

![1644482446598](嵌入式笔记.assets/1644482446598.png)

![1644482582409](嵌入式笔记.assets/1644482582409.png)

####4、指令集

 ![1644483590726](嵌入式笔记.assets/1644483590726.png)

![1644484046948](嵌入式笔记.assets/1644484046948.png)

**编译原理：**所以在不同的处理器上运行需要安装不同的编译器

![1644484486391](嵌入式笔记.assets/1644484486391.png)

### 3、ARM存储模型

#### 1、数据类型和存储要求

字节对齐是可以提高CPU的处理效率，不需要去进行识别和裁剪

![1644485084440](嵌入式笔记.assets/1644485084440.png)

![1644485429877](嵌入式笔记.assets/1644485429877.png)

int a=0x12345678  ，其中12为高位（注意大小端对齐是对单个数据表示而言，像到了数组是不用考虑的，但是数组中的元素在内存中的存储需要考虑，其实就是按字节解读数据的顺序）

![1644485919380](嵌入式笔记.assets/1644485919380.png)

==因为取址是按4个字节去取的，所以最低2个bit一定是0，当在写程序pc的最低2个bit非0时，会被强制转为0（向下取4的整数倍的地址）。

 ### 4、ARM的八种工作模式

![1644493567159](嵌入式笔记.assets/1644493567159.png)

### 5、补充c/c++内存分区

![1644506477915](嵌入式笔记.assets/1644506477915.png)

![1644506693932](嵌入式笔记.assets/1644506693932.png)

![1644506767972](嵌入式笔记.assets/1644506767972.png)



## 4、ARM开发环境搭建

#### 1、教程

![1644541327149](嵌入式笔记.assets/1644541327149.png)

# ARM开发学习

## 1、工作模式和寄存器框图

![1644929968033](嵌入式笔记.assets/1644929968033.png)

![1644930096881](嵌入式笔记.assets/1644930096881.png)

## 2、CPSR寄存器

![1644930925773](嵌入式笔记.assets/1644930925773.png)

## 3、ARM指令

###1、搬移指令

![1644931258859](嵌入式笔记.assets/1644931258859.png)

----------------







# 基于4412学习linux和ARM

## 1、ARM学习

### 1、开发学习的框架

- Linux系统的搭建过程

  应用、内核、硬件

  ![1644932007511](嵌入式笔记.assets/1644932007511.png)

- 芯片性能与用途相对于，降低成本。

- 框架学习方法：![1644933298368](嵌入式笔记.assets/1644933298368.png)


### 2、ARM指令

![1645100643208](嵌入式笔记.assets/1645100643208.png)

机器码为32位，所以涉及到一个操作数为立即数如果过大时，需要使用伪指令ldr进行赋值



1. 搬移指令：mov，mrs，msr

   ![1645101032892](嵌入式笔记.assets/1645101032892.png)


2. 条件执行：一个cmp可供下面多条条件执行使用

- 状态寄存器高四位用于条件判断

![1645100814288](嵌入式笔记.assets/1645100814288.png)



![1645099741806](嵌入式笔记.assets/1645099741806.png)

3. 逻辑指令：

   ![1645104504210](嵌入式笔记.assets/1645104504210.png)

4. 算术指令：

   ![1645106232870](嵌入式笔记.assets/1645106232870.png)

5. 跳转指令：

   ![1645106360759](嵌入式笔记.assets/1645106360759.png)

   在函数结束时写一个标号fun_end:MOV PC,LR（==当嵌套调用函数时，需要使用一个寄存器记录返回的地址值==）

   ==tips:编写汇编可以先用c语言实现，再转化为汇编进行实现==

6. load和store指令：

   ![1645109457177](嵌入式笔记.assets/1645109457177.png)

7. 前索引和后索引：

   ![1645111947352](嵌入式笔记.assets/1645111947352.png)

   8. GNU汇编伪指令（程序段）：

      ![1645150965651](嵌入式笔记.assets/1645150965651.png)

   9. 批量操作指令

      ![1645151535743](嵌入式笔记.assets/1645151535743.png)

   10. 堆栈操作指令：

       ![1645151864155](嵌入式笔记.assets/1645151864155.png)

       首先是需要保存中断函数跳转地址LR，将其压栈，方便后续mov lr ，pc跳出中断

       其次是^是因为进入中断模式会改变，需要保存原来的模式转态，在中断结束后恢复原来的模式

       总的来说进入中断保护现场就是保护寄存器中的值，需要保护的寄存器有R0-R12，LR，cpsr

### 3、异常处理

#### 1、定义：处理突发事件的机制

#### 2、异常种类：

![1645153511463](嵌入式笔记.assets/1645153511463.png)

#### 3、中断异常

- 异常处理过程：CPU 扫描，检测到有触发信号（电平触发和边沿触发），置位中断标志位（防止中断丢失），从中断矢量表（启动文件中定义的）找到进入中断函数的入口，中断控制器进行映射，进栈的保护现场，中断函数处理（清除中断标志），中断返回（包括出栈 恢复现场）

- 最简单的软中断程序的实现：

  ![1645158126078](嵌入式笔记.assets/1645158126078.png)

  ![1645160170732](嵌入式笔记.assets/1645160170732.png)

    以下根据软中断号的不同执行不同分支的内容：

  ![1645170924804](嵌入式笔记.assets/1645170924804.png)

  在swi_handler中获取软中断号存于r0，用sub r0，lr，#4进行获取本身b swi_handler这个指令的地址存于r0，间址出该指令的内容，再获取软中断编号

  ​

  ==b跳转指令只能上下跳转32M空间，因为一条 机器指令占的空间有限，使用类似立即数的方法进行赋值给pc即可，但是得定义swi_handler的字存储位置（如下图）==，ldr实现由原本立即数直接存于指令转变为地址存于指令，突破存储位数的限制

  ![1645171984917](嵌入式笔记.assets/1645171984917.png)

#### 4、开发环境的搭建（裸机与交叉编译）

==裸机开发还是借助stm32进行学习，使用到可以上linux系统的使用在系统上进行文件操作来对外设进行驱动控制，而且stm32还有成熟的库函数，但其实linux底层的驱动也是在直接与硬件打交道，只是用的是库函数和虚拟地址==

- 本地编译与交叉编译

  ![1645187236817](嵌入式笔记.assets/1645187376214.png)

  采用交叉编译的原因是运行linux系统的muc资源受限，借助x86的性能在Ubuntu下进行编译后，下载到muc中


- 交叉编译环境的搭建

  ![1645179492166](嵌入式笔记.assets/1645179492166.png)

  在vscode下进行代码编写，在keil中进行仿真，在linux下使用arm的编译环境进行编译生成文件，使用rs232串口在windows下使用超级终端烧录到板子上，在uboot模式下输入==loadb +下载在板子flash的哪个地址==，然后选择传入二进制文件，即可在flash上面下载，输入go就可以运行了（==还可以参考讯为的裸机开发文档==）

- 一般的开发流程：先通过原理图找到要控制的外设对应的CPU管脚，去芯片手册查看对应的特殊功能寄存器的位描述，写程序修改寄存器的值实现对应的功能控制。（关键是看懂原理图和芯片手册，多使用搜索功能）

- keil编译调试环境的搭建：新建工程并选择芯片，将keil关联到ARM的交叉编译工具链，可以到下面网站进行下载并安装[arm-none-linux-gnueabi-gcc下载 - 代码天地 (codetd.com)](https://www.codetd.com/article/885380)

  **流程如下**：![1644541327149](嵌入式笔记.assets/1644541327149.png)

- Ubuntu上安装arm-gcc：apt-get install gcc-arm-linux-gnueabihf

  然后就可以在Ubuntu上使用arm-gcc对程序进行编译然后可以在ARM平台上运行

- 为了方便后续在Ubuntu系统上编译程序后传给开发板，安装NFS，可以实现文件夹共享

  ![1645189626302](嵌入式笔记.assets/1645189626302.png)

  ​

  ![1645189395903](嵌入式笔记.assets/1645189395903.png)

  ​


## 2、烧写镜像

读卡器和USB接入虚拟机需要将虚拟机设置为1.1

### 1、制作可以烧写镜像的TF卡

- 进入开发板uboot模式下将TF卡进行格式分区
- 之后在Ubuntu下制作uboot  （参考制作QT镜像那一个章节）
- 最后在TF卡中新建文件夹sdupdate
- 将镜像文件拷贝到此文件夹下
- 最后将TF卡插入TF卡槽，在开发板uboot模式下执行命令进行烧写。


tip：在做好TF卡的情况下，可以使用TF卡启动（TF卡中已经做好了可以启动的Uboot，制作步骤是进行上面的前两个步骤），并在TF卡中的文件夹sdupdate下放置uboot镜像，并执行烧写命令，烧写完毕后可以将启动模式修改为EMMC启动

### 2、编译uboot和kernel

uboot：执行编译脚本 .sh文件 后续会生成uboot.bin文件可用于烧写。

kernel：将源码拷贝去Ubuntu中解压后，选择对应的配置文件在当前目录下拷贝为 .config

再执行zImage，等待编译完成，会在 ./arch/arm/boot/zImage下生成了镜像文件，如果还需要使用安卓wifi功能需要执行make modules，  后面只需要将内核镜像使用TF卡烧入到开发板即可（烧写方法在上面）。

## 3、ext2文件系统

- ext2文件系统介绍：[EXT2 文件系统 - AlanTu - 博客园 (cnblogs.com)](https://www.cnblogs.com/alantu2018/p/8459905.html)

## 4、uboot

- uboot包括固化在固件中的boot代码和BootLoader
- BootLoader作用就是在**操作系统运行内核前运行的一段程序**，**初始化硬件设备、建立内存空间映射图、为加载内核做准备**。
- BootLoader 是依赖硬件的，所以不同的硬件需要实现的BootLoader不一样，没有通用性。

Uboot引导程序 分为 BL1（放在引导设备中）、BL2、U-boot和TZSW

最终需要补齐到328k：Uboot的makefile有几句编译命令用0补全到328k

在BL1中会进行安全保护 ，加载时进行各种安全检验，同时BL1也会对BL2进行安全检验，同时还有校验和签名

- uboot常用命令**教程p101**

## 5、裸机程序 

在进入uboot命令行后使用dnw进行程序下载。

程序需要使用交叉编译环境将启动文件start.S和源代码进行联合编译，使用makefile管理，最终生成二进制文件，可以使用dnw进行下载到内存中，并运行。

## 6、Linux内核

### 1、特点：

- 可移植性 ，支持的硬件 平台广
- ​

### 2、Linux内核简介

- 用户空间的进程有自己的虚拟地址空间，内核占用单独的地址空间
- 内核划分为三层
  1. 系统调用：提供了进入内核的接口，库函数的实现也是借助系统调用进入内核
  2. 内核代码
  3. 依赖于体系结构的代码，板级支持包（BSP），不同处理器不一样（类比不同的单片机板子，需要的硬件接口等不一样），在源码中/linux/arch中可以找到

### 3、Linux内核子系统

- 系统调用
- 进程管理
- 内存管理
- 虚拟文件系统
- 网络堆栈
- 设备驱动代码

### 4、Linux 内核的裁剪和配置

- menuconfig

  使用menuconfig这个根据对内核进行裁剪（对需要的功能进行选择），使用menuconfig修改了配置文件后，.config文件会被修改，再次进行编译内核时，会根据新的.config进行编译整个内核。比如是否需要某个驱动就可以使用menuconfig将其打开或者关闭

  ==menuconfig修改最终就是影响.config，而.config最后是影响编译的，最终makefile使用条件编译对已经在menuconfig中配置的编译进内核==

- Kconfig

  是一个菜单语法文件，同时会影响makefile中的内容，menuconfig中的每一项和Kconfig和makefile对应。（需要自己写时只需要模仿即可）

### 5、内核编译

- 需要将编译器的解压路径和环境变量中添加的路径（.bashrc）对应。在编译使用的makefile中的CROSS_COMPILE参数就是使用的交叉编译器的路径
- ==需要确保编译器解压路径和环境变量中的路径和makefile中交叉编译器的路径三者保持一致即可。==
- 编译过程中可能出现错误，需要挨个去排查，通过添加库文件或者修改库文件使编译通过。
- 编译流程：make zImage ->运行makefile找到编译器路径，系统根据环境变量找到编译器路径

### 6、制作linux最小系统

- 下载busybox到某个文件夹下，并解压

- 使用与内核编译配置一样的命令，make menuconfig配置busybox，选择交叉编译器（此处注意要配置好编译器的环境变量），接着配置make install生成的二进制文件的位置

- 完善最小系统

  1. 网络文件、用户文件、库。（busybox编译生成的二进制文件为动态链接的，所以需要拷贝编译器中的库文件到lib目录下）
  2. 将文件中的内容完善并修改文件权限。
  3. system文件下的文件系统

  ![1650698658288](嵌入式笔记.assets/1650698658288.png)

  etc文件夹下的文件：

  ![1650698700923](嵌入式笔记.assets/1650698700923.png)

  init.d文件夹下的文件：

  ![1650698748255](嵌入式笔记.assets/1650698748255.png)

  最后使用make_ext4fs 进行打包生成镜像，此镜像就可以烧写到板子上了，前提是要有uboot，内核zImage和ramdisk-uboot.img使用QtE的即可。

  最后需要4个文件，如果没有uboot需要先烧写uboot（方法是在制作好的TF卡中存储uboot的镜像，然后开发板以TF启动，之后进入uboot模式将uboot烧写进板子），有了uboot之后只需在制作好的TF卡中将镜像放进sdupdate文件夹下，最后在超级终端输入烧录镜像的命令即可。

--------------------------------

# C语言学习

## 1、输入输出函数

- fputs：成功，其中每个函数都将返回一个非负值。 发生错误时，**fputs** 将返回 **EOF**。

  puts：用于打印字符串，遇到空字符停止。

```c
int fputs(
   const char *str,
   FILE *stream
);
```

- fgets：限制获取的字符串长度，遇到"\0"（会丢弃后面的字符，缓冲区需要自己处理）或读了numchars-1时停止，并返回。

  如果读到文件尾或者超长，返回NULL。

```c
char *fgets(
   char *str,
   int numChars,
   FILE *stream
);
```

- gets_s:超出则会把buffer首地址赋值为\0(空字符)，并返回NULL

```c
char *gets_s(
   char *buffer,
   size_t sizeInCharacters
);
```

- putchar:打印单个字符
- getchar:从==缓冲区==读取单个字符




- scanf：不会做越界判断，可能会出现段错误，越界会修改不知道什么地方的数据。访问越界的数据存在风险，每次可能运行的结果不一样，是未知的。

























